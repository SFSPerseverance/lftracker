<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LFTRACKER — Photos</title>

  <!-- Press Start 2P -->
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

  <style>
    :root{
      --accent: rgb(255,170,0);
      --bg: #0b0c10;
      --panel: #111217;
      --white: #FFFFFF;
      --radius: 10px;
      --stroke: 3px;
      --invalid: #ff4d4f;
      --valid: #4caf50;
    }

    /* Global */
    * { box-sizing: border-box; font-family: 'Press Start 2P', monospace; color: var(--white); }
    html,body { height:100%; margin:0; background: var(--bg); }
    .wrap { max-width:1000px; margin:28px auto; padding:18px; }
    h1 { color: var(--accent); margin:0 0 8px; font-size:18px; text-align:center; }
    p.lead { color:var(--white); opacity:0.95; text-align:center; font-size:11px; margin:8px 0 18px 0; }

    .panel { background:var(--panel); border-radius:var(--radius); border:var(--stroke) solid var(--accent); padding:16px; }
    .grid { display:grid; grid-template-columns: 1fr 520px; gap:18px; align-items:start; }

    label { display:block; font-size:10px; margin-bottom:8px; color:var(--white); }

    /* Controls */
    .controls .control { width:100%; margin-bottom:12px; }
    select, input[type="text"], button, .fake-file {
      font-family: 'Press Start 2P', monospace;
      background: transparent;
      color: var(--white);
      border-radius: 8px;
      border: 2px solid var(--accent);
      padding: 10px;
      font-size:11px;
      width:100%;
      text-align:left;
      cursor:pointer;
      -webkit-appearance: none;
      appearance: none;
    }

    /* Force dropdown list dark where possible */
    select, option {
      background: #0b0c10 !important;
      color: #FFFFFF !important;
    }

    .inline-row { display:flex; gap:8px; align-items:center; }
    .small-note { font-size:10px; opacity:0.9; color:var(--white); }

    /* Fake file button (we use a label tied to input) */
    .fake-file { display:flex; align-items:center; gap:12px; justify-content:flex-start; height:48px; background: transparent; }
    .fake-file svg { width:26px; height:26px; flex:0 0 26px; }

    .submit-btn { background: var(--accent); color:#000; border:2px solid rgba(0,0,0,0.25); padding:10px; border-radius:8px; cursor:pointer; font-size:11px; }

    .meta { font-size:10px; color:var(--white); opacity:0.9; margin-top:6px; }

    /* Canvas */
    .canvas-wrap { background:#060607; border-radius:var(--radius); padding:12px; border:var(--stroke) solid var(--accent); display:flex; flex-direction:column; gap:10px; align-items:center; }
    .canvas-box { width:100%; max-width:820px; background:#000; border-radius:8px; overflow:hidden; position:relative; aspect-ratio:16/9; }
    #mainCanvas { width:100%; height:100%; display:block; background:#000; }

    .preview-area { display:flex; gap:12px; align-items:center; justify-content:center; flex-wrap:wrap; margin-top:6px; }
    #previewCanvas { width:320px; height:180px; border-radius:8px; border:2px solid rgba(255,255,255,0.06); background:#000; }

    /* validation badges */
    .badge {
      display:inline-block;
      font-size:10px;
      padding:6px 8px;
      border-radius:6px;
      color:#000;
      background:var(--valid);
      min-width:80px;
      text-align:center;
    }
    .badge.invalid { background:var(--invalid); color:#fff; }

    .helper { font-size:11px; color:#bbb; margin-top:6px; }

    /* upload progress */
    .progress {
      height: 10px;
      background: rgba(255,255,255,0.06);
      border-radius: 6px;
      overflow: hidden;
      margin-top: 8px;
    }
    .progress > div {
      height:100%;
      width:0%;
      background: var(--accent);
      transition: width 0.12s linear;
    }

    /* hide the real input */
    #fileInput { display:none; }

    @media (max-width:980px){
      .grid { grid-template-columns: 1fr; }
      .canvas-wrap { order:-1; }
      #previewCanvas { width:240px; height:135px; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>LFTRACKER — Photos</h1>
    <p class="lead">Upload photos, choose aircraft and livery, enter your Roblox ID (validated), and adjust a 16:9 crop (live preview).</p>

    <div class="panel grid">
      <!-- Left: controls -->
      <div class="controls">
        <label for="fileInput">Choose image</label>

        <!-- native label -> single native file picker trigger -->
        <label for="fileInput" class="fake-file control" id="fileLabel" title="Browse image">
          <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" fill="none" stroke="rgb(255,170,0)" stroke-width="3" stroke-linejoin="round" stroke-linecap="round" aria-hidden="true">
            <rect x="6" y="12" width="52" height="36" rx="4" ry="4" fill="transparent"></rect>
            <rect x="10" y="16" width="44" height="12" rx="2" ry="2" fill="transparent"></rect>
            <rect x="18" y="34" width="10" height="8" rx="1" ry="1" fill="transparent"></rect>
            <rect x="36" y="34" width="10" height="8" rx="1" ry="1" fill="transparent"></rect>
          </svg>
          <span style="font-size:11px">Browse Image</span>
        </label>

        <input id="fileInput" type="file" accept="image/*">

        <label for="planeSelect">Aircraft</label>
        <select id="planeSelect" class="control" aria-label="Aircraft"></select>

        <label for="liverySelect">Livery</label>
        <select id="liverySelect" class="control" aria-label="Livery"></select>

        <label for="robloxId">Roblox user ID</label>
        <div class="inline-row">
          <input id="robloxId" type="text" placeholder="Enter your Roblox user ID" class="control" style="flex:1" />
          <div id="robloxBadge" style="flex:0 0 auto; margin-left:6px;"></div>
        </div>
        <div id="robloxHelper" class="helper">ID must be numeric. Validation via RoProxy.</div>

        <button id="submitBtn" class="submit-btn control" disabled>Upload</button>

        <div id="uploadStatus" class="helper" style="margin-top:8px"></div>
        <div class="progress" style="display:none" id="progressBar"><div></div></div>
      </div>

      <!-- Right: canvas & preview -->
      <div class="canvas-wrap">
        <label>Image / Crop Area</label>
        <div class="canvas-box">
          <canvas id="mainCanvas"></canvas>
        </div>

        <div class="preview-area">
          <div>
            <div style="font-size:10px; margin-bottom:6px;">Cropped preview (live)</div>
            <canvas id="previewCanvas" width="1280" height="720"></canvas>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Supabase client -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/supabase.min.js"></script>

  <script>
    /***********************
     CONFIG — your Supabase project
     You gave the URL & anon key — we use the anon key for client uploads.
     Do NOT expose service_role key in client-side code.
    ***********************/
    const SUPABASE_URL = 'https://qhffydtxzlwoxgllvtif.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFoZmZ5ZHR4emx3b3hnbGx2dGlmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI1NzkwNjAsImV4cCI6MjA3ODE1NTA2MH0.CAacFj8c14KlGu0HJ_1Zjf6hVadaGd5hPJleH8zftIQ';

    const supabase = supabasejs.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    /********************************************************
     Aircraft list & liveries (unchanged)
    *********************************************************/
    const aircraftList = [
      {icao:'BA11', name:'BAC 1-11'},
      {icao:'B731', name:'Boeing 737-100'},
      {icao:'B732', name:'Boeing 737-200'},
      {icao:'B733', name:'Boeing 737-300'},
      {icao:'B734', name:'Boeing 737-400'},
      {icao:'B735', name:'Boeing 737-500'},
      {icao:'B73D', name:'Boeing 737-DEV'},
      {icao:'L101', name:'Lockheed L-1011 TriStar'},
      {icao:'CL60', name:'Bombardier Challenger 600'},
      {icao:'TBM7', name:'Socata TBM-700'},
      {icao:'A10', name:'Fairchild Republic A-10'},
      {icao:'MISC', name:'Miscellaneous'}
    ];

    const liveries = {
      'AzureJet': ['B735','B734','B733','B732','B731'],
      'Classic': ['BA11','L101','B731','B732'],
      'VIP': ['CL60','B735'],
      'Military': ['A10'],
      'General Aviation': ['TBM7','CL60'],
      'Special': ['MISC']
    };

    /********************************************************
      UI elements
    *********************************************************/
    const fileInput = document.getElementById('fileInput');
    const planeSelect = document.getElementById('planeSelect');
    const liverySelect = document.getElementById('liverySelect');
    const robloxIdInput = document.getElementById('robloxId');
    const robloxBadge = document.getElementById('robloxBadge');
    const robloxHelper = document.getElementById('robloxHelper');
    const submitBtn = document.getElementById('submitBtn');
    const uploadStatus = document.getElementById('uploadStatus');
    const progressBar = document.getElementById('progressBar');
    const progressInner = progressBar.querySelector('div');

    // helper maps
    const icaoToAircraft = Object.fromEntries(aircraftList.map(a => [a.icao, a]));

    // Populate plane select (no empty option)
    function populatePlanes(defaultICAO=null){
      planeSelect.innerHTML = '';
      aircraftList.forEach(a => {
        const opt = document.createElement('option');
        opt.value = a.icao;
        opt.textContent = `${a.name} (${a.icao})`;
        planeSelect.appendChild(opt);
      });
      if(defaultICAO && icaoToAircraft[defaultICAO]) planeSelect.value = defaultICAO;
      else planeSelect.selectedIndex = 0;
    }

    function liveriesForICAO(icao){
      return Object.keys(liveries).filter(k => liveries[k].includes(icao));
    }

    function populateLiveriesForPlane(icao, preferredLivery=null){
      const options = liveriesForICAO(icao);
      liverySelect.innerHTML = '';
      const finalOptions = options.length ? options : ['Default'];
      finalOptions.forEach(name => {
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = name;
        liverySelect.appendChild(opt);
      });
      if(preferredLivery && finalOptions.includes(preferredLivery)) liverySelect.value = preferredLivery;
      else liverySelect.selectedIndex = 0;
    }

    function ensurePlaneForLivery(preferredPlane=null){
      const chosenLivery = liverySelect.value;
      const aircraftForLivery = Object.keys(icaoToAircraft).filter(icao => (liveries[chosenLivery] || []).includes(icao));
      if(!aircraftForLivery.length){
        if(preferredPlane && icaoToAircraft[preferredPlane]) planeSelect.value = preferredPlane;
        else planeSelect.selectedIndex = 0;
        return;
      }
      if(aircraftForLivery.includes(planeSelect.value)) return;
      planeSelect.value = aircraftForLivery[0];
      populateLiveriesForPlane(planeSelect.value, liverySelect.value);
    }

    // initial population
    populatePlanes();
    populateLiveriesForPlane(planeSelect.value);

    planeSelect.addEventListener('change', () => {
      const prev = liverySelect.value;
      populateLiveriesForPlane(planeSelect.value, prev);
      updateSubmitState();
    });

    liverySelect.addEventListener('change', () => {
      ensurePlaneForLivery();
      populateLiveriesForPlane(planeSelect.value, liverySelect.value);
      updateSubmitState();
    });

    /********************************************************
      Roblox ID validation via RoProxy
    *********************************************************/
    let validateTimer = null;
    let lastValidatedId = null;
    let lastValidResult = null;

    function setBadgeValid(name){
      robloxBadge.innerHTML = '';
      const span = document.createElement('div');
      span.className = 'badge';
      span.textContent = name;
      robloxBadge.appendChild(span);
    }
    function setBadgeInvalid(msg){
      robloxBadge.innerHTML = '';
      const span = document.createElement('div');
      span.className = 'badge invalid';
      span.textContent = msg;
      robloxBadge.appendChild(span);
    }
    function clearBadge(){ robloxBadge.innerHTML = ''; }

    function isNumericId(s){ return /^\d+$/.test(s); }

    function updateSubmitState(){
      const hasImage = !!fileInput.files[0];
      const plane = planeSelect.value;
      const livery = liverySelect.value;
      const robloxOk = !!lastValidResult;
      submitBtn.disabled = !(hasImage && plane && livery && robloxOk);
    }

    async function validateRobloxId(id){
      if(!id || !isNumericId(id)){
        lastValidatedId = id;
        lastValidResult = null;
        setBadgeInvalid('Invalid ID');
        updateSubmitState();
        return;
      }
      if(lastValidatedId === id && lastValidResult) {
        setBadgeValid(lastValidResult.displayName || lastValidResult.name || ('@' + lastValidResult.id));
        updateSubmitState();
        return;
      }

      // checking badge
      robloxBadge.innerHTML = '';
      const checking = document.createElement('div');
      checking.className = 'badge';
      checking.style.background = 'transparent';
      checking.style.color = 'var(--white)';
      checking.style.border = '2px solid rgba(255,255,255,0.08)';
      checking.textContent = 'Checking...';
      robloxBadge.appendChild(checking);

      const endpoint = `https://users.roproxy.com/v1/users/${encodeURIComponent(id)}`;
      try {
        const r = await fetch(endpoint, { method: 'GET' });
        if(r.ok){
          const data = await r.json();
          lastValidatedId = id;
          lastValidResult = data;
          const display = data.displayName || data.name || ('@' + data.id);
          setBadgeValid(display);
          robloxHelper.textContent = 'Validated via RoProxy.';
        } else if(r.status === 404){
          lastValidatedId = id;
          lastValidResult = null;
          setBadgeInvalid('Not found');
          robloxHelper.textContent = 'No Roblox user with that ID.';
        } else {
          lastValidatedId = id;
          lastValidResult = null;
          setBadgeInvalid('Validation failed');
          robloxHelper.textContent = 'Validation failed — try again';
        }
      } catch (err) {
        lastValidatedId = id;
        lastValidResult = null;
        setBadgeInvalid('Network error');
        robloxHelper.textContent = 'Network error while validating — try again';
      }
      updateSubmitState();
    }

    // numeric-only typing + debounce
    robloxIdInput.addEventListener('input', (e) => {
      const cleaned = (e.target.value || '').replace(/[^\d]/g,'');
      if(cleaned !== e.target.value) e.target.value = cleaned;
      if(validateTimer) clearTimeout(validateTimer);
      validateTimer = setTimeout(()=> validateRobloxId(cleaned), 600);
      lastValidResult = null;
      clearBadge();
      robloxHelper.textContent = 'ID must be numeric. Validation via RoProxy.';
      updateSubmitState();
    });

    robloxIdInput.addEventListener('blur', (e) => {
      const id = (e.target.value || '').trim();
      if(validateTimer) { clearTimeout(validateTimer); validateTimer = null; }
      validateRobloxId(id);
    });

    /********************************************************
      Canvas & cropper code (custom cropper, live preview)
    *********************************************************/
    const mainCanvas = document.getElementById('mainCanvas');
    const ctx = mainCanvas.getContext('2d', {alpha:false});
    const previewCanvas = document.getElementById('previewCanvas');
    const pctx = previewCanvas.getContext('2d', {alpha:false});

    let image = new Image();
    let imgLoaded = false;
    let drawArea = {x:0,y:0,w:0,h:0};

    function resizeMainCanvas(){
      const box = mainCanvas.parentElement.getBoundingClientRect();
      mainCanvas.width = Math.floor(box.width);
      mainCanvas.height = Math.floor(box.width * 9/16);
    }

    // crop rect (default)
    let crop = {x:20, y:20, w: Math.floor(640*0.7), h: Math.floor((640*0.7)*9/16) };
    const minCropW = 80;
    const handleSize = 20;
    let state = { dragging:false, resizing:false, resizeEdge:null, startX:0, startY:0, startCrop:null };
    let activePointerId = null;

    function clearMain(){ ctx.fillStyle = '#000'; ctx.fillRect(0,0,mainCanvas.width,mainCanvas.height); }

    function fitImageToCanvas(){
      if(!imgLoaded) return;
      const cw = mainCanvas.width, ch = mainCanvas.height;
      const iw = image.width, ih = image.height;
      const canvasRatio = cw / ch;
      const imgRatio = iw / ih;
      let drawW, drawH, offsetX, offsetY;
      if(imgRatio > canvasRatio){
        drawW = cw;
        drawH = Math.round(cw / imgRatio);
        offsetX = 0;
        offsetY = Math.round((ch - drawH)/2);
      } else {
        drawH = ch;
        drawW = Math.round(ch * imgRatio);
        offsetY = 0;
        offsetX = Math.round((cw - drawW)/2);
      }
      drawArea = { x: offsetX, y: offsetY, w: drawW, h: drawH };
      ctx.drawImage(image, offsetX, offsetY, drawW, drawH);
    }

    function drawOverlayAndCrop(){
      if(!imgLoaded) return;
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.fillRect(drawArea.x, drawArea.y, drawArea.w, drawArea.h);

      const sx = Math.max(drawArea.x, crop.x);
      const sy = Math.max(drawArea.y, crop.y);
      const sw = Math.max(0, Math.min(drawArea.x + drawArea.w, crop.x + crop.w) - sx);
      const sh = Math.max(0, Math.min(drawArea.y + drawArea.h, crop.y + crop.h) - sy);
      if(sw > 0 && sh > 0) {
        const scaleX = image.width / drawArea.w;
        const scaleY = image.height / drawArea.h;
        const srcX = (sx - drawArea.x) * scaleX;
        const srcY = (sy - drawArea.y) * scaleY;
        const srcW = sw * scaleX;
        const srcH = sh * scaleY;
        ctx.drawImage(image, srcX, srcY, srcW, srcH, sx, sy, sw, sh);
      }

      // border and handles
      ctx.lineWidth = 3;
      ctx.strokeStyle = 'rgb(255,170,0)';
      ctx.strokeRect(crop.x + 0.5, crop.y + 0.5, crop.w - 1, crop.h - 1);

      const hs = handleSize;
      const handles = [
        {x: crop.x - hs/2, y: crop.y - hs/2, name:'nw'},
        {x: crop.x + crop.w - hs/2, y: crop.y - hs/2, name:'ne'},
        {x: crop.x - hs/2, y: crop.y + crop.h - hs/2, name:'sw'},
        {x: crop.x + crop.w - hs/2, y: crop.y + crop.h - hs/2, name:'se'},
        {x: crop.x + crop.w/2 - hs/2, y: crop.y - hs/2, name:'n'},
        {x: crop.x + crop.w/2 - hs/2, y: crop.y + crop.h - hs/2, name:'s'},
        {x: crop.x - hs/2, y: crop.y + crop.h/2 - hs/2, name:'w'},
        {x: crop.x + crop.w - hs/2, y: crop.y + crop.h/2 - hs/2, name:'e'}
      ];
      ctx.fillStyle = 'rgb(255,170,0)';
      handles.forEach(h => ctx.fillRect(h.x, h.y, hs, hs));
    }

    function renderAll(){
      clearMain();
      if(!imgLoaded) return;
      fitImageToCanvas();
      drawOverlayAndCrop();
      updatePreview();
    }

    function toCanvasCoords(evt){
      const rect = mainCanvas.getBoundingClientRect();
      const x = (evt.clientX - rect.left) * (mainCanvas.width / rect.width);
      const y = (evt.clientY - rect.top) * (mainCanvas.height / rect.height);
      return {x, y};
    }

    function detectHit(x, y){
      const tol = Math.max(12, handleSize/2);
      const corners = {
        nw: {x: crop.x, y: crop.y},
        ne: {x: crop.x + crop.w, y: crop.y},
        sw: {x: crop.x, y: crop.y + crop.h},
        se: {x: crop.x + crop.w, y: crop.y + crop.h}
      };
      for(const k in corners){
        const p = corners[k];
        if(Math.abs(x - p.x) <= tol && Math.abs(y - p.y) <= tol) return {type:'corner', which:k};
      }
      if(y >= crop.y - tol && y <= crop.y + tol && x >= crop.x - tol && x <= crop.x + crop.w + tol) return {type:'edge', which:'n'};
      if(y >= crop.y + crop.h - tol && y <= crop.y + crop.h + tol && x >= crop.x - tol && x <= crop.x + crop.w + tol) return {type:'edge', which:'s'};
      if(x >= crop.x - tol && x <= crop.x + tol && y >= crop.y - tol && y <= crop.y + crop.h + tol) return {type:'edge', which:'w'};
      if(x >= crop.x + crop.w - tol && x <= crop.x + crop.w + tol && y >= crop.y - tol && y <= crop.y + crop.h + tol) return {type:'edge', which:'e'};
      if(x > crop.x + tol && x < crop.x + crop.w - tol && y > crop.y + tol && y < crop.y + crop.h - tol) return {type:'inside'};
      return {type:'none'};
    }

    mainCanvas.addEventListener('pointerdown', (e) => {
      if(!imgLoaded) return;
      mainCanvas.setPointerCapture(e.pointerId);
      activePointerId = e.pointerId;
      const pos = toCanvasCoords(e);
      const hit = detectHit(pos.x, pos.y);
      state.startX = pos.x; state.startY = pos.y; state.startCrop = {...crop};
      if(hit.type === 'corner') { state.resizing = true; state.resizeEdge = hit.which; }
      else if(hit.type === 'edge') { state.resizing = true; state.resizeEdge = hit.which; }
      else if(hit.type === 'inside') { state.dragging = true; }
      else { state.dragging = false; state.resizing = false; state.resizeEdge = null; }
    });

    mainCanvas.addEventListener('pointermove', (e) => {
      if(activePointerId !== null && e.pointerId !== activePointerId) return;
      const pos = toCanvasCoords(e);
      const hit = detectHit(pos.x, pos.y);

      // cursor mapping
      let cursor = 'default';
      if(hit.type === 'corner'){
        if(hit.which === 'nw' || hit.which === 'se') cursor = 'nwse-resize';
        else cursor = 'nesw-resize';
      } else if(hit.type === 'edge'){
        if(hit.which === 'n' || hit.which === 's') cursor = 'ns-resize';
        else if(hit.which === 'e' || hit.which === 'w') cursor = 'ew-resize';
      } else if(hit.type === 'inside'){
        cursor = 'move';
      }
      mainCanvas.style.cursor = cursor;

      if(state.dragging){
        const dx = pos.x - state.startX;
        const dy = pos.y - state.startY;
        crop.x = Math.max(drawArea.x, Math.min(drawArea.x + drawArea.w - crop.w, state.startCrop.x + dx));
        crop.y = Math.max(drawArea.y, Math.min(drawArea.y + drawArea.h - crop.h, state.startCrop.y + dy));
        renderAll();
      } else if(state.resizing){
        const which = state.resizeEdge;
        let newCrop = {...state.startCrop};
        const dx = pos.x - state.startX;
        const dy = pos.y - state.startY;

        // Corners
        if(which === 'se'){
          newCrop.w = Math.max(minCropW, Math.round(state.startCrop.w + dx));
          newCrop.h = Math.round(newCrop.w * 9/16);
        } else if(which === 'sw'){
          newCrop.w = Math.max(minCropW, Math.round(state.startCrop.w - dx));
          newCrop.h = Math.round(newCrop.w * 9/16);
          newCrop.x = state.startCrop.x + (state.startCrop.w - newCrop.w);
        } else if(which === 'ne'){
          newCrop.w = Math.max(minCropW, Math.round(state.startCrop.w + dx));
          newCrop.h = Math.round(newCrop.w * 9/16);
          newCrop.y = state.startCrop.y + (state.startCrop.h - newCrop.h);
        } else if(which === 'nw'){
          newCrop.w = Math.max(minCropW, Math.round(state.startCrop.w - dx));
          newCrop.h = Math.round(newCrop.w * 9/16);
          newCrop.x = state.startCrop.x + (state.startCrop.w - newCrop.w);
          newCrop.y = state.startCrop.y + (state.startCrop.h - newCrop.h);

        // Sides: keep aspect ratio, adjust orthogonal pos to keep centered
        } else if(which === 'e'){
          newCrop.w = Math.max(minCropW, Math.round(state.startCrop.w + dx));
          newCrop.h = Math.round(newCrop.w * 9/16);
          newCrop.y = Math.round(state.startCrop.y + (state.startCrop.h - newCrop.h)/2);
        } else if(which === 'w'){
          newCrop.w = Math.max(minCropW, Math.round(state.startCrop.w - dx));
          newCrop.h = Math.round(newCrop.w * 9/16);
          newCrop.x = state.startCrop.x + (state.startCrop.w - newCrop.w);
          newCrop.y = Math.round(state.startCrop.y + (state.startCrop.h - newCrop.h)/2);
        } else if(which === 'n'){
          newCrop.h = Math.max(Math.round(minCropW * 9/16), Math.round(state.startCrop.h - dy));
          newCrop.w = Math.round(newCrop.h * 16/9);
          newCrop.y = state.startCrop.y + (state.startCrop.h - newCrop.h);
          newCrop.x = Math.round(state.startCrop.x + (state.startCrop.w - newCrop.w)/2);
        } else if(which === 's'){
          newCrop.h = Math.max(Math.round(minCropW * 9/16), Math.round(state.startCrop.h + dy));
          newCrop.w = Math.round(newCrop.h * 16/9);
          newCrop.x = Math.round(state.startCrop.x + (state.startCrop.w - newCrop.w)/2);
        }

        // clamp to drawArea boundaries
        if(newCrop.w > drawArea.w) newCrop.w = drawArea.w;
        if(newCrop.h > drawArea.h) newCrop.h = drawArea.h;
        if(newCrop.x < drawArea.x) newCrop.x = drawArea.x;
        if(newCrop.y < drawArea.y) newCrop.y = drawArea.y;
        if(newCrop.x + newCrop.w > drawArea.x + drawArea.w) newCrop.x = drawArea.x + drawArea.w - newCrop.w;
        if(newCrop.y + newCrop.h > drawArea.y + drawArea.h) newCrop.y = drawArea.y + drawArea.h - newCrop.h;

        crop = newCrop;
        renderAll();
      }
    });

    mainCanvas.addEventListener('pointerup', (e) => {
      if(activePointerId !== null && e.pointerId !== activePointerId) return;
      try{ mainCanvas.releasePointerCapture(e.pointerId); } catch(_) {}
      activePointerId = null;
      state.dragging = false; state.resizing = false; state.resizeEdge = null;
    });

    /********************************************************
      File input handling (native label => single-click)
    *********************************************************/
    fileInput.addEventListener('change', () => {
      const f = fileInput.files[0];
      if(!f) return;
      const url = URL.createObjectURL(f);
      image = new Image();
      image.onload = () => {
        imgLoaded = true;
        resizeMainCanvas();
        crop.w = Math.floor(mainCanvas.width * 0.7);
        crop.h = Math.round(crop.w * 9/16);
        crop.x = Math.round((mainCanvas.width - crop.w)/2);
        crop.y = Math.round((mainCanvas.height - crop.h)/2);
        renderAll();
        URL.revokeObjectURL(url);
        updateSubmitState();
      };
      image.src = url;
    });

    /********************************************************
      Live preview: draw the cropped area to previewCanvas
    *********************************************************/
    function updatePreview(){
      if(!imgLoaded){
        pctx.fillStyle = '#000';
        pctx.fillRect(0,0,previewCanvas.width, previewCanvas.height);
        return;
      }
      previewCanvas.width = 1280;
      previewCanvas.height = Math.round(previewCanvas.width * 9/16);

      const sx = Math.max(drawArea.x, crop.x);
      const sy = Math.max(drawArea.y, crop.y);
      const sw = Math.max(0, Math.min(drawArea.x + drawArea.w, crop.x + crop.w) - sx);
      const sh = Math.max(0, Math.min(drawArea.y + drawArea.h, crop.y + crop.h) - sy);

      if(sw <= 0 || sh <= 0){
        pctx.fillStyle = '#000';
        pctx.fillRect(0,0,previewCanvas.width, previewCanvas.height);
        return;
      }

      const scaleX = image.width / drawArea.w;
      const scaleY = image.height / drawArea.h;
      const srcX = (sx - drawArea.x) * scaleX;
      const srcY = (sy - drawArea.y) * scaleY;
      const srcW = sw * scaleX;
      const srcH = sh * scaleY;

      pctx.fillStyle = '#000';
      pctx.fillRect(0,0,previewCanvas.width, previewCanvas.height);
      pctx.drawImage(image, srcX, srcY, srcW, srcH, 0, 0, previewCanvas.width, previewCanvas.height);
    }

    /********************************************************
      SUPABASE UPLOAD + METADATA INSERT
    *********************************************************/
    // Helper: build a unique storage path
    function buildPath(filename){
      const ts = new Date().toISOString().replace(/[:.]/g,'-');
      const ext = (filename.split('.').pop() || 'jpg').toLowerCase();
      const rand = Math.random().toString(36).slice(2,9);
      return `photos/${ts}_${rand}.${ext}`;
    }

    // Compute crop in original image pixel coordinates (srcX,srcY,srcW,srcH) and include image original size
    function computeCropJson(){
      if(!imgLoaded) return null;
      const sx = Math.max(drawArea.x, crop.x);
      const sy = Math.max(drawArea.y, crop.y);
      const sw = Math.max(0, Math.min(drawArea.x + drawArea.w, crop.x + crop.w) - sx);
      const sh = Math.max(0, Math.min(drawArea.y + drawArea.h, crop.y + crop.h) - sy);
      const scaleX = image.width / drawArea.w;
      const scaleY = image.height / drawArea.h;
      const srcX = Math.round((sx - drawArea.x) * scaleX);
      const srcY = Math.round((sy - drawArea.y) * scaleY);
      const srcW = Math.round(sw * scaleX);
      const srcH = Math.round(sh * scaleY);
      return {
        srcX, srcY, srcW, srcH,
        imageWidth: image.width,
        imageHeight: image.height,
        normalized: {
          x: +(srcX / image.width).toFixed(6),
          y: +(srcY / image.height).toFixed(6),
          w: +(srcW / image.width).toFixed(6),
          h: +(srcH / image.height).toFixed(6)
        }
      };
    }

    // Upload flow: upload file to storage, get public URL, insert metadata row
    async function uploadPhotoAndMetadata(file, meta, onProgress = null){
      // 1) path
      const path = buildPath(file.name);

      // 2) upload to bucket named 'photos'
      // Supabase JS v2 streaming upload doesn't provide progress in-browser easily;
      // We'll use upload() and fake progress bar updates for UX.
      progressBar.style.display = 'block';
      progressInner.style.width = '4%';
      uploadStatus.textContent = 'Uploading file...';

      const { data: uploadData, error: uploadErr } = await supabase.storage
        .from('photos')
        .upload(path, file, { cacheControl: '3600', upsert: false });

      if(uploadErr){
        progressBar.style.display = 'none';
        throw uploadErr;
      }

      progressInner.style.width = '60%';
      uploadStatus.textContent = 'Creating public URL...';

      // 3) get public url
      const { data: publicData } = supabase.storage.from('photos').getPublicUrl(path);
      const publicUrl = publicData && publicData.publicUrl ? publicData.publicUrl : null;

      progressInner.style.width = '85%';
      uploadStatus.textContent = 'Saving metadata...';

      // 4) insert metadata row into "photos" table
      const insertRow = {
        file_path: path,
        public_url: publicUrl,
        icao: meta.icao,
        livery: meta.livery,
        roblox_id: meta.robloxId,
        crop_json: meta.crop || null
      };

      const { data: rowData, error: rowErr } = await supabase
        .from('photos')
        .insert([insertRow])
        .select()
        .single();

      if(rowErr){
        // attempt to cleanup uploaded file
        try { await supabase.storage.from('photos').remove([path]); } catch(_) {}
        progressBar.style.display = 'none';
        throw rowErr;
      }

      progressInner.style.width = '100%';
      uploadStatus.textContent = 'Upload complete!';
      setTimeout(()=> { progressBar.style.display = 'none'; progressInner.style.width = '0%'; }, 900);

      return { row: rowData, publicUrl };
    }

    /********************************************************
      Wire submit button
    *********************************************************/
    submitBtn.addEventListener('click', async () => {
      const file = fileInput.files[0];
      const plane = planeSelect.value;
      const livery = liverySelect.value;
      const robloxId = robloxIdInput.value.trim();

      if(!file || !plane || !livery || !lastValidResult){
        uploadStatus.textContent = 'Fill required fields and validate Roblox ID.';
        return;
      }

      // disable UI
      submitBtn.disabled = true;
      submitBtn.textContent = 'Uploading...';
      uploadStatus.textContent = '';

      const cropJson = computeCropJson();
      const meta = { icao: plane, livery: livery, robloxId: robloxId, crop: cropJson };

      try {
        const res = await uploadPhotoAndMetadata(file, meta);
        uploadStatus.innerHTML = `Uploaded — <a href="${res.publicUrl}" target="_blank" style="color:var(--accent)">view image</a>`;
        // reset small bits
        submitBtn.textContent = 'Upload';
        // optionally clear file input
        // fileInput.value = '';
        updateSubmitState();
      } catch (err) {
        console.error('Upload error', err);
        uploadStatus.textContent = 'Upload failed: ' + (err.message || JSON.stringify(err));
        submitBtn.textContent = 'Upload';
        updateSubmitState();
      } finally {
        submitBtn.disabled = false;
      }
    });

    /********************************************************
      Init & responsiveness
    *********************************************************/
    function init(){
      populatePlanes();
      populateLiveriesForPlane(planeSelect.value);
      resizeMainCanvas();
      crop.w = Math.floor(mainCanvas.width * 0.7);
      crop.h = Math.round(crop.w * 9/16);
      crop.x = Math.round((mainCanvas.width - crop.w)/2);
      crop.y = Math.round((mainCanvas.height - crop.h)/2);
      renderAll();
      updateSubmitState();
    }

    window.addEventListener('load', init);
    window.addEventListener('resize', ()=>{
      const prevW = mainCanvas.width;
      resizeMainCanvas();
      const ratio = mainCanvas.width / (prevW || mainCanvas.width);
      crop.w = Math.max(minCropW, Math.round(crop.w * ratio));
      crop.h = Math.round(crop.w * 9/16);
      crop.x = Math.round((mainCanvas.width - crop.w)/2);
      crop.y = Math.round((mainCanvas.height - crop.h)/2);
      renderAll();
      updateSubmitState();
    });
  </script>
</body>
</html>
