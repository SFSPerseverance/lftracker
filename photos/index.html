<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LFTRACKER — Photos</title>

  <!-- Press Start 2P font -->
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

  <style>
    :root{
      --accent: rgb(255,170,0);
      --bg: #0b0c10;
      --panel: #111217;
      --muted: #bdbdbd;
      --radius: 10px;
      --stroke: 3px;
      --white: #ffffff;
    }

    /* Global */
    html,body{height:100%;margin:0;background:var(--bg);color:var(--white);font-family:'Press Start 2P',monospace}
    * {box-sizing:border-box}
    /* Ensure font everywhere */
    input, select, button, label, option, canvas, p, div { font-family: 'Press Start 2P', monospace !important; color: #FFFFFF !important; -webkit-text-stroke: 2px #000000; text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000; }

    .wrap{max-width:980px;margin:28px auto;padding:20px;box-sizing:border-box}
    h1{
      color:var(--accent);
      text-align:center;
      margin:0 0 14px 0;
      font-size:18px;
    }
    p.lead{
      text-align:center;
      color:var(--white);
      margin:8px 0 24px 0;
      font-size:10px;
    }

    .panel{
      background:var(--panel);
      border-radius:var(--radius);
      border: var(--stroke) solid var(--accent);
      padding:18px;
      box-sizing:border-box;
    }

    .grid{
      display:grid;
      grid-template-columns: 1fr 420px;
      gap:18px;
      align-items:start;
    }

    label {
      display:block;
      font-size:10px;
      margin-bottom:6px;
      color:var(--white);
    }

    /* Controls all the same width */
    .controls .control {
      width:100%;
      margin-bottom:12px;
    }

    select, .fake-file-button, button {
      width:100%;
      box-sizing:border-box;
      padding:10px;
      background:#0f1114;
      color:var(--white);
      border-radius:8px;
      border: 2px solid rgba(255,255,255,0.03);
      font-size:11px;
      outline:none;
      text-align:left;
    }

    /* Submit button */
    .submit-btn{
      background:var(--accent);
      color:#000;
      font-weight:700;
      cursor:pointer;
      border: var(--stroke) solid rgba(0,0,0,0.25);
      padding:10px;
      border-radius:8px;
    }

    /* Canvas & preview */
    .canvas-wrap{
      background:#060607;
      border-radius:var(--radius);
      padding:12px;
      border: var(--stroke) solid var(--accent);
      display:flex;
      flex-direction:column;
      gap:10px;
      align-items:center;
    }

    .canvas-box{
      width:100%;
      max-width:640px;
      background:#000;
      border-radius:8px;
      overflow:hidden;
      position:relative;
      aspect-ratio: 16 / 9;
    }

    canvas{
      width:100%;
      height:100%;
      display:block;
      image-rendering:auto;
      background:#000;
    }

    .preview-area{
      width:100%;
      display:flex;
      justify-content:center;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
    }

    .preview-area canvas{
      width:320px;
      height:180px;
      border-radius:8px;
      border:2px solid rgba(255,255,255,0.06);
      background:#000;
    }

    footer{
      margin-top:18px;
      font-size:10px;
      color:var(--white);
      text-align:center;
    }

    /* hidden real file input */
    #fileInput{ display:none }

    /* Fake Windows95-style storage drive icon button */
    .fake-file-button{
      display:flex;
      align-items:center;
      justify-content:center;
      gap:10px;
      height:48px;
      background:transparent;
      border-radius:8px;
      border: var(--stroke) solid var(--accent);
      cursor:pointer;
      color:var(--white);
    }

    .drive-svg{
      width:28px;
      height:28px;
      display:block;
      flex:0 0 28px;
    }

    .meta{
      margin-top:12px;
      color:var(--white);
      font-size:10px;
    }

    @media (max-width:880px){
      .grid{grid-template-columns:1fr}
      .canvas-wrap{order: -1}
      .preview-area canvas{width:240px;height:135px}
    }

    /* Crop rectangle visuals drawn on main canvas. no extra CSS needed */
  </style>
</head>
<body>
  <div class="wrap">
    <h1>LFTRACKER — Photos</h1>
    <p class="lead">Upload photos of aircraft seen on LFTracker. Choose livery, pick the aircraft (ICAO stored), adjust a 16:9 crop and preview live.</p>

    <div class="panel grid">
      <!-- Left: form controls -->
      <div class="controls">
        <label for="fileInput">Choose image</label>

        <!-- hidden real input; label triggers it -->
        <input id="fileInput" type="file" accept="image/*">

        <label class="control">
          <span class="fake-file-button" id="fileBtn" title="Upload image">
            <!-- Windows 95-style storage drive / floppy icon (outline, transparent fill) -->
            <svg class="drive-svg" viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" fill="none" stroke="rgb(255,170,0)" stroke-width="3" stroke-linejoin="round" stroke-linecap="round">
              <!-- body -->
              <rect x="6" y="12" width="52" height="36" rx="4" ry="4" fill="transparent"></rect>
              <!-- label slot -->
              <rect x="10" y="16" width="44" height="12" rx="2" ry="2" fill="transparent"></rect>
              <!-- small details -->
              <rect x="18" y="34" width="10" height="8" rx="1" ry="1" fill="transparent"></rect>
              <rect x="36" y="34" width="10" height="8" rx="1" ry="1" fill="transparent"></rect>
            </svg>
            <span style="font-size:11px; color:#FFFFFF; -webkit-text-stroke:2px #000;">Browse Image</span>
          </span>
        </label>

        <label for="liverySelect">Livery</label>
        <select id="liverySelect" class="control">
          <option value="__ALL__">— All Liveries —</option>
        </select>

        <label for="planeSelect">Aircraft (display name; value = ICAO)</label>
        <select id="planeSelect" class="control">
          <option value="">Select plane</option>
        </select>

        <button id="submitBtn" class="submit-btn control">Submit (no backend yet)</button>

        <div class="meta">
          <div>ICAO codes are stored as the option values. Cropped preview updates live as you move/resize the 16:9 crop.</div>
        </div>
      </div>

      <!-- Right: canvas & preview -->
      <div class="canvas-wrap">
        <label>Image / Crop Area</label>
        <div class="canvas-box">
          <canvas id="mainCanvas"></canvas>
        </div>

        <div class="preview-area">
          <div>
            <div style="font-size:10px;color:#FFFFFF; margin-bottom:6px; -webkit-text-stroke:2px #000;">Cropped preview (live)</div>
            <canvas id="previewCanvas" width="640" height="360"></canvas>
          </div>
        </div>
      </div>
    </div>

    <footer>© 2025 LFTracker — sfsperseverance.github.io</footer>
  </div>

  <script>
    /***************
     Data
    ***************/
    const aircraftList = [
      {icao:'BA11', name:'BAC One-Eleven'},
      {icao:'B731', name:'Boeing 737-100'},
      {icao:'B732', name:'Boeing 737-200'},
      {icao:'B733', name:'Boeing 737-300'},
      {icao:'B734', name:'Boeing 737-400'},
      {icao:'B735', name:'Boeing 737-500'},
      {icao:'B73D', name:'Boeing 737-DEV'},
      {icao:'L101', name:'Lockheed L-1011 TriStar'},
      {icao:'CL60', name:'Bombardier Challenger 600'},
      {icao:'TBM7', name:'Socata TBM-700'},
      {icao:'A10', name:'Fairchild Republic A-10'},
      {icao:'MISC', name:'Miscellaneous'}
    ];

    const liveries = {
      'AzureJet': ['B735','B734','B733','B732','B731'],
      'Classic': ['BA11','L101','B731','B732'],
      'VIP': ['CL60','B735'],
      'Military': ['A10'],
      'General Aviation': ['TBM7','CL60'],
      'All': aircraftList.map(a => a.icao),
      'Special': ['MISC']
    };

    // UI elements
    const fileInput = document.getElementById('fileInput');
    const fileBtn = document.getElementById('fileBtn');
    const liverySelect = document.getElementById('liverySelect');
    const planeSelect = document.getElementById('planeSelect');
    const submitBtn = document.getElementById('submitBtn');

    // canvases
    const mainCanvas = document.getElementById('mainCanvas');
    const ctx = mainCanvas.getContext('2d', {alpha:false});
    const previewCanvas = document.getElementById('previewCanvas');
    const pctx = previewCanvas.getContext('2d', {alpha:false});

    // populate selects
    Object.keys(liveries).forEach(key=>{
      const opt = document.createElement('option');
      opt.value = key;
      opt.textContent = key;
      liverySelect.appendChild(opt);
    });

    function fillPlaneOptions(filterICAOs=null){
      planeSelect.innerHTML = '<option value="">Select plane</option>';
      const list = aircraftList.filter(a => !filterICAOs || filterICAOs.includes(a.icao));
      list.forEach(a=>{
        const o = document.createElement('option');
        o.value = a.icao;
        o.textContent = a.name + ' ('+a.icao+')';
        planeSelect.appendChild(o);
      });
    }
    fillPlaneOptions();

    liverySelect.addEventListener('change', ()=>{
      const val = liverySelect.value;
      if(val === '__ALL__') fillPlaneOptions();
      else fillPlaneOptions(liveries[val] || []);
    });

    // hook up the fake button to file input
    fileBtn.addEventListener('click', ()=> fileInput.click());

    /***************
     Image & crop logic
     - Fit image inside mainCanvas preserving aspect ratio
     - Draw crop rectangle locked to 16:9
     - Allow drag move and easier resizing from edges and corners
     - Live update preview whenever crop or image changes
    ***************/
    let image = new Image();
    let imgLoaded = false;
    let drawArea = {x:0,y:0,w:0,h:0};

    // Set main canvas size responsively (match container aspect ratio 16:9)
    function resizeMainCanvas(){
      const box = mainCanvas.parentElement.getBoundingClientRect();
      // ensure integer pixel size for crispness
      mainCanvas.width = Math.floor(box.width);
      mainCanvas.height = Math.floor(box.width * 9/16);
    }

    function setInitialCrop(){
      crop.w = Math.round(mainCanvas.width * 0.7);
      crop.h = Math.round(crop.w * 9/16);
      crop.x = Math.round((mainCanvas.width - crop.w)/2);
      crop.y = Math.round((mainCanvas.height - crop.h)/2);
    }

    // crop rect
    let crop = {x:20,y:20,w:320,h:180};
    const minCropW = 80;
    const handleSize = 20; // larger handle for easier resizing
    let state = { dragging:false, resizing:false, resizeEdge:null, startX:0, startY:0, startCrop:null };

    // helpers
    function clearMain(){
      ctx.fillStyle = '#000';
      ctx.fillRect(0,0,mainCanvas.width,mainCanvas.height);
    }

    function fitImageToCanvas(){
      if(!imgLoaded) return;
      const cw = mainCanvas.width, ch = mainCanvas.height;
      const iw = image.width, ih = image.height;
      const canvasRatio = cw / ch;
      const imgRatio = iw / ih;
      let drawW, drawH, offsetX, offsetY;
      if(imgRatio > canvasRatio){
        drawW = cw;
        drawH = Math.round(cw / imgRatio);
        offsetX = 0;
        offsetY = Math.round((ch - drawH) / 2);
      } else {
        drawH = ch;
        drawW = Math.round(ch * imgRatio);
        offsetY = 0;
        offsetX = Math.round((cw - drawW) / 2);
      }
      drawArea = {x: offsetX, y: offsetY, w: drawW, h: drawH};
      ctx.drawImage(image, offsetX, offsetY, drawW, drawH);
    }

    function drawOverlayAndCrop(){
      if(!imgLoaded) return;
      // dark overlay over draw area
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.fillRect(drawArea.x, drawArea.y, drawArea.w, drawArea.h);
      // compute intersection crop vs drawArea
      const sx = Math.max(drawArea.x, crop.x);
      const sy = Math.max(drawArea.y, crop.y);
      const sw = Math.max(0, Math.min(drawArea.x+drawArea.w, crop.x+crop.w) - sx);
      const sh = Math.max(0, Math.min(drawArea.y+drawArea.h, crop.y+crop.h) - sy);
      if(sw>0 && sh>0){
        const scaleX = image.width / drawArea.w;
        const scaleY = image.height / drawArea.h;
        const srcX = (sx - drawArea.x) * scaleX;
        const srcY = (sy - drawArea.y) * scaleY;
        const srcW = sw * scaleX;
        const srcH = sh * scaleY;
        ctx.drawImage(image, srcX, srcY, srcW, srcH, sx, sy, sw, sh);
      }
      // draw border
      ctx.lineWidth = 3;
      ctx.strokeStyle = 'rgb(255,170,0)';
      ctx.strokeRect(crop.x + 0.5, crop.y + 0.5, crop.w - 1, crop.h - 1);

      // draw handles: corners and edges
      const hs = handleSize;
      const handles = [
        {x: crop.x - hs/2, y: crop.y - hs/2, cursor: 'nwse-resize', name:'nw'},
        {x: crop.x + crop.w - hs/2, y: crop.y - hs/2, cursor: 'nesw-resize', name:'ne'},
        {x: crop.x - hs/2, y: crop.y + crop.h - hs/2, cursor: 'nesw-resize', name:'sw'},
        {x: crop.x + crop.w - hs/2, y: crop.y + crop.h - hs/2, cursor: 'nwse-resize', name:'se'}
      ];
      ctx.fillStyle = 'rgb(255,170,0)';
      handles.forEach(h=>{
        ctx.fillRect(h.x, h.y, hs, hs);
      });
      // edge handles (centered)
      const edges = [
        {x: crop.x + crop.w/2 - hs/2, y: crop.y - hs/2, name:'n'},
        {x: crop.x + crop.w/2 - hs/2, y: crop.y + crop.h - hs/2, name:'s'},
        {x: crop.x - hs/2, y: crop.y + crop.h/2 - hs/2, name:'w'},
        {x: crop.x + crop.w - hs/2, y: crop.y + crop.h/2 - hs/2, name:'e'}
      ];
      edges.forEach(h=>{
        ctx.fillRect(h.x, h.y, hs, hs);
      });
    }

    function renderAll(){
      clearMain();
      if(!imgLoaded) return;
      fitImageToCanvas();
      drawOverlayAndCrop();
      updatePreview(); // live preview
    }

    // map pointer to canvas coordinates (account bounding rect)
    function toCanvasCoords(evt){
      const rect = mainCanvas.getBoundingClientRect();
      const x = (evt.clientX - rect.left) * (mainCanvas.width / rect.width);
      const y = (evt.clientY - rect.top) * (mainCanvas.height / rect.height);
      return {x, y};
    }

    // detect pointer near handle/edge/crop
    function detectHit(x,y){
      const tol = Math.max(12, handleSize/2);
      // corners
      const corners = {
        nw: {x: crop.x, y: crop.y},
        ne: {x: crop.x + crop.w, y: crop.y},
        sw: {x: crop.x, y: crop.y + crop.h},
        se: {x: crop.x + crop.w, y: crop.y + crop.h}
      };
      for(const k in corners){
        const p = corners[k];
        if(Math.abs(x - p.x) <= tol && Math.abs(y - p.y) <= tol) return {type:'corner', which:k};
      }
      // edges
      const edges = {
        n: {x1: crop.x, x2: crop.x+crop.w, y: crop.y},
        s: {x1: crop.x, x2: crop.x+crop.w, y: crop.y+crop.h},
        w: {x: crop.x, y1: crop.y, y2: crop.y+crop.h},
        e: {x: crop.x+crop.w, y1: crop.y, y2: crop.y+crop.h}
      };
      if(y >= crop.y - tol && y <= crop.y + tol && x >= crop.x - tol && x <= crop.x + crop.w + tol) return {type:'edge', which:'n'};
      if(y >= crop.y + crop.h - tol && y <= crop.y + crop.h + tol && x >= crop.x - tol && x <= crop.x + crop.w + tol) return {type:'edge', which:'s'};
      if(x >= crop.x - tol && x <= crop.x + tol && y >= crop.y - tol && y <= crop.y + crop.h + tol) return {type:'edge', which:'w'};
      if(x >= crop.x + crop.w - tol && x <= crop.x + crop.w + tol && y >= crop.y - tol && y <= crop.y + crop.h + tol) return {type:'edge', which:'e'};
      // inside
      if(x > crop.x + tol && x < crop.x + crop.w - tol && y > crop.y + tol && y < crop.y + crop.h - tol) return {type:'inside'};
      return {type:'none'};
    }

    // pointer events
    let pointerId = null;
    mainCanvas.addEventListener('pointerdown', (e)=>{
      if(!imgLoaded) return;
      mainCanvas.setPointerCapture(e.pointerId);
      pointerId = e.pointerId;
      const pos = toCanvasCoords(e);
      const hit = detectHit(pos.x, pos.y);
      state.startX = pos.x; state.startY = pos.y; state.startCrop = {...crop};
      if(hit.type === 'corner') { state.resizing = true; state.resizeEdge = hit.which; }
      else if(hit.type === 'edge') { state.resizing = true; state.resizeEdge = hit.which; }
      else if(hit.type === 'inside') { state.dragging = true; }
      else { state.dragging = false; state.resizing = false; state.resizeEdge = null; }
    });

    mainCanvas.addEventListener('pointermove', (e)=>{
      if(pointerId !== null && e.pointerId !== pointerId) return;
      const pos = toCanvasCoords(e);
      // update cursor for UX
      const hit = detectHit(pos.x, pos.y);
      // set cursor style on parent container
      const curs = (hit.type === 'corner') ? 'nwse-resize' : (hit.type === 'edge') ? 'ns-resize' : (hit.type === 'inside') ? 'move' : 'default';
      mainCanvas.style.cursor = curs;

      if(state.dragging){
        const dx = pos.x - state.startX;
        const dy = pos.y - state.startY;
        crop.x = Math.max(drawArea.x, Math.min(drawArea.x + drawArea.w - crop.w, state.startCrop.x + dx));
        crop.y = Math.max(drawArea.y, Math.min(drawArea.y + drawArea.h - crop.h, state.startCrop.y + dy));
        renderAll();
      } else if(state.resizing){
        // resizing with aspect locked to 16:9
        const which = state.resizeEdge;
        // We'll compute new width based on pointer delta depending on edge/corner
        let newCrop = {...state.startCrop};
        const dx = pos.x - state.startX;
        const dy = pos.y - state.startY;
        if(which === 'se'){
          newCrop.w = Math.max(minCropW, state.startCrop.w + dx);
          newCrop.h = Math.round(newCrop.w * 9/16);
        } else if(which === 'sw'){
          newCrop.w = Math.max(minCropW, state.startCrop.w - dx);
          newCrop.h = Math.round(newCrop.w * 9/16);
          newCrop.x = state.startCrop.x + (state.startCrop.w - newCrop.w);
        } else if(which === 'ne'){
          newCrop.w = Math.max(minCropW, state.startCrop.w + dx);
          newCrop.h = Math.round(newCrop.w * 9/16);
          newCrop.y = state.startCrop.y + (state.startCrop.h - newCrop.h);
        } else if(which === 'nw'){
          newCrop.w = Math.max(minCropW, state.startCrop.w - dx);
          newCrop.h = Math.round(newCrop.w * 9/16);
          newCrop.x = state.startCrop.x + (state.startCrop.w - newCrop.w);
          newCrop.y = state.startCrop.y + (state.startCrop.h - newCrop.h);
        } else if(which === 'e'){
          newCrop.w = Math.max(minCropW, state.startCrop.w + dx);
          newCrop.h = Math.round(newCrop.w * 9/16);
        } else if(which === 'w'){
          newCrop.w = Math.max(minCropW, state.startCrop.w - dx);
          newCrop.h = Math.round(newCrop.w * 9/16);
          newCrop.x = state.startCrop.x + (state.startCrop.w - newCrop.w);
        } else if(which === 'n'){
          newCrop.h = Math.max( Math.round(minCropW*9/16), state.startCrop.h - dy );
          newCrop.w = Math.round(newCrop.h * 16/9);
          newCrop.y = state.startCrop.y + (state.startCrop.h - newCrop.h);
        } else if(which === 's'){
          newCrop.h = Math.max( Math.round(minCropW*9/16), state.startCrop.h + dy );
          newCrop.w = Math.round(newCrop.h * 16/9);
        }
        // clamp to draw area
        if(newCrop.w > drawArea.w) newCrop.w = drawArea.w;
        if(newCrop.h > drawArea.h) newCrop.h = drawArea.h;
        if(newCrop.x < drawArea.x) newCrop.x = drawArea.x;
        if(newCrop.y < drawArea.y) newCrop.y = drawArea.y;
        if(newCrop.x + newCrop.w > drawArea.x + drawArea.w) newCrop.x = drawArea.x + drawArea.w - newCrop.w;
        if(newCrop.y + newCrop.h > drawArea.y + drawArea.h) newCrop.y = drawArea.y + drawArea.h - newCrop.h;

        crop = newCrop;
        renderAll();
      }
    });

    mainCanvas.addEventListener('pointerup', (e)=>{
      if(pointerId !== null && e.pointerId !== pointerId) return;
      mainCanvas.releasePointerCapture(e.pointerId);
      pointerId = null;
      state.dragging = false; state.resizing = false; state.resizeEdge = null;
    });

    // On image load
    fileInput.addEventListener('change', ()=>{
      const f = fileInput.files[0];
      if(!f) return;
      const url = URL.createObjectURL(f);
      image = new Image();
      image.onload = ()=>{
        imgLoaded = true;
        // resize canvas to parent
        resizeMainCanvas();
        setInitialCrop();
        renderAll();
        // free object URL when safe
        URL.revokeObjectURL(url);
      };
      image.src = url;
    });

    // live preview update: map crop->image source and draw to previewCanvas
    function updatePreview(){
      if(!imgLoaded) {
        // clear preview
        pctx.fillStyle = '#000';
        pctx.fillRect(0,0,previewCanvas.width,previewCanvas.height);
        return;
      }
      // ensure preview canvas resolution
      previewCanvas.width = 1280;
      previewCanvas.height = Math.round(previewCanvas.width * 9/16);
      // derive intersection of crop and drawArea
      const sx = Math.max(drawArea.x, crop.x);
      const sy = Math.max(drawArea.y, crop.y);
      const sw = Math.max(0, Math.min(drawArea.x+drawArea.w, crop.x+crop.w) - sx);
      const sh = Math.max(0, Math.min(drawArea.y+drawArea.h, crop.y+crop.h) - sy);
      if(sw <= 0 || sh <= 0){
        pctx.fillStyle = '#000';
        pctx.fillRect(0,0,previewCanvas.width,previewCanvas.height);
        return;
      }
      const scaleX = image.width / drawArea.w;
      const scaleY = image.height / drawArea.h;
      const srcX = (sx - drawArea.x) * scaleX;
      const srcY = (sy - drawArea.y) * scaleY;
      const srcW = sw * scaleX;
      const srcH = sh * scaleY;
      pctx.fillStyle = '#000';
      pctx.fillRect(0,0,previewCanvas.width,previewCanvas.height);
      pctx.drawImage(image, srcX, srcY, srcW, srcH, 0,0, previewCanvas.width, previewCanvas.height);
    }

    // Submit: produce dataURL from current preview (no backend)
    submitBtn.addEventListener('click', ()=>{
      const plane = planeSelect.value;
      const livery = liverySelect.value;
      if(!fileInput.files[0] || !plane || !livery){
        // silent failure: flash submit button (no popups)
        submitBtn.style.opacity = '0.6';
        setTimeout(()=> submitBtn.style.opacity = '1', 250);
        return;
      }
      // produce dataURL (could be uploaded)
      const dataURL = previewCanvas.toDataURL('image/jpeg', 0.9);
      // show it in a new tab (no alerts). This demonstrates result but does not upload.
      const win = window.open();
      if(win){
        win.document.write('<title>Cropped image</title><img src="'+dataURL+'" style="max-width:100%;">');
      }
    });

    // initial sizing on load and on resize
    function init(){
      resizeMainCanvas();
      setInitialCrop();
      renderAll();
    }
    window.addEventListener('load', init);
    window.addEventListener('resize', ()=>{
      const prev = {...crop};
      resizeMainCanvas();
      // scale crop proportionally
      const scaleW = mainCanvas.width / (prev.canvasW || mainCanvas.width);
      // naive attempt: keep center and width proportion
      crop.w = Math.round(crop.w * (mainCanvas.width / (prev.canvasW || mainCanvas.width)));
      crop.h = Math.round(crop.w * 9/16);
      crop.x = Math.round((mainCanvas.width - crop.w)/2);
      crop.y = Math.round((mainCanvas.height - crop.h)/2);
      renderAll();
    });

    // ensure drawArea is updated on every renderAll
    // exported for debugging if needed: window._debug = { crop, renderAll };

  </script>
</body>
</html>
