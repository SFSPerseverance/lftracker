<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LFTRACKER — Photos</title>

  <!-- Press Start 2P -->
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

  <style>
    :root{
      --accent: rgb(255,170,0);
      --bg: #0b0c10;
      --panel: #111217;
      --white: #FFFFFF;
      --radius: 10px;
      --stroke: 3px;
    }

    /* Global */
    * { box-sizing: border-box; font-family: 'Press Start 2P', monospace; color: var(--white); }
    html,body { height:100%; margin:0; background: var(--bg); }
    .wrap { max-width:1000px; margin:28px auto; padding:18px; }
    h1 { color: var(--accent); margin:0 0 8px; font-size:18px; text-align:center; }
    p.lead { color:var(--white); opacity:0.95; text-align:center; font-size:11px; margin:8px 0 18px 0; }

    .panel { background:var(--panel); border-radius:var(--radius); border:var(--stroke) solid var(--accent); padding:16px; }
    .grid { display:grid; grid-template-columns: 1fr 520px; gap:18px; align-items:start; }

    label { display:block; font-size:10px; margin-bottom:8px; color:var(--white); }

    /* Controls */
    .controls .control { width:100%; margin-bottom:12px; }
    select, input[type="text"], button, .fake-file {
      font-family: 'Press Start 2P', monospace;
      background: transparent;
      color: var(--white);
      border-radius: 8px;
      border: 2px solid var(--accent);
      padding: 10px;
      font-size:11px;
      width:100%;
      text-align:left;
      cursor:pointer;
      -webkit-appearance: none;
      appearance: none;
    }

    /* Force dropdown list dark where possible */
    select, option {
      background: #0b0c10 !important;
      color: #FFFFFF !important;
    }

    /* Fake file button (we use a label tied to input) */
    .fake-file { display:flex; align-items:center; gap:12px; justify-content:flex-start; height:48px; background: transparent; }
    .fake-file svg { width:26px; height:26px; flex:0 0 26px; }

    .submit-btn { background: var(--accent); color:#000; border:2px solid rgba(0,0,0,0.25); padding:10px; border-radius:8px; cursor:pointer; font-size:11px; }

    .meta { font-size:10px; color:var(--white); opacity:0.9; margin-top:6px; }

    /* Canvas */
    .canvas-wrap { background:#060607; border-radius:var(--radius); padding:12px; border:var(--stroke) solid var(--accent); display:flex; flex-direction:column; gap:10px; align-items:center; }
    .canvas-box { width:100%; max-width:820px; background:#000; border-radius:8px; overflow:hidden; position:relative; aspect-ratio:16/9; }
    #mainCanvas { width:100%; height:100%; display:block; background:#000; }

    .preview-area { display:flex; gap:12px; align-items:center; justify-content:center; flex-wrap:wrap; margin-top:6px; }
    #previewCanvas { width:320px; height:180px; border-radius:8px; border:2px solid rgba(255,255,255,0.06); background:#000; }

    /* hide the real input */
    #fileInput { display:none; }

    @media (max-width:980px){
      .grid { grid-template-columns: 1fr; }
      .canvas-wrap { order:-1; }
      #previewCanvas { width:240px; height:135px; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>LFTRACKER — Photos</h1>
    <p class="lead">Upload photos, choose aircraft and livery, adjust 16:9 crop (live preview).</p>

    <div class="panel grid">
      <!-- Left: controls -->
      <div class="controls">
        <label for="fileInput">Choose image</label>

        <!-- native label -> single native file picker trigger -->
        <label for="fileInput" class="fake-file control" id="fileLabel" title="Browse image">
          <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" fill="none" stroke="rgb(255,170,0)" stroke-width="3" stroke-linejoin="round" stroke-linecap="round" aria-hidden="true">
            <rect x="6" y="12" width="52" height="36" rx="4" ry="4" fill="transparent"></rect>
            <rect x="10" y="16" width="44" height="12" rx="2" ry="2" fill="transparent"></rect>
            <rect x="18" y="34" width="10" height="8" rx="1" ry="1" fill="transparent"></rect>
            <rect x="36" y="34" width="10" height="8" rx="1" ry="1" fill="transparent"></rect>
          </svg>
          <span style="font-size:11px">Browse Image</span>
        </label>

        <input id="fileInput" type="file" accept="image/*">

        <label for="planeSelect">Aircraft</label>
        <select id="planeSelect" class="control" aria-label="Aircraft"></select>

        <label for="liverySelect">Livery</label>
        <select id="liverySelect" class="control" aria-label="Livery"></select>

        <label for="robloxId">Roblox user ID</label>
        <input id="robloxId" type="text" placeholder="Enter your Roblox user ID" class="control" />

        <button id="submitBtn" class="submit-btn control">Submit (demo)</button>
      </div>

      <!-- Right: canvas & preview -->
      <div class="canvas-wrap">
        <label>Image / Crop Area</label>
        <div class="canvas-box">
          <canvas id="mainCanvas"></canvas>
        </div>

        <div class="preview-area">
          <div>
            <div style="font-size:10px; margin-bottom:6px;">Cropped preview (live)</div>
            <canvas id="previewCanvas" width="1280" height="720"></canvas>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    /********************************************************
     Aircraft list (exact ones you requested)
     liveries: key => array of ICAO codes
    *********************************************************/
    const aircraftList = [
      {icao:'BA11', name:'BAC 1-11'},
      {icao:'B731', name:'Boeing 737-100'},
      {icao:'B732', name:'Boeing 737-200'},
      {icao:'B733', name:'Boeing 737-300'},
      {icao:'B734', name:'Boeing 737-400'},
      {icao:'B735', name:'Boeing 737-500'},
      {icao:'B73D', name:'Boeing 737-DEV'},
      {icao:'L101', name:'Lockheed L-1011 TriStar'},
      {icao:'CL60', name:'Bombardier Challenger 600'},
      {icao:'TBM7', name:'Socata TBM-700'},
      {icao:'A10', name:'Fairchild Republic A-10'},
      {icao:'MISC', name:'Miscellaneous'}
    ];

    const liveries = {
      'AzureJet': ['B735','B734','B733','B732','B731'],
      'Classic': ['BA11','L101','B731','B732'],
      'VIP': ['CL60','B735'],
      'Military': ['A10'],
      'General Aviation': ['TBM7','CL60'],
      'Special': ['MISC']
    };

    /********************************************************
      UI elements
    *********************************************************/
    const fileInput = document.getElementById('fileInput');
    const planeSelect = document.getElementById('planeSelect');
    const liverySelect = document.getElementById('liverySelect');
    const robloxIdInput = document.getElementById('robloxId');
    const submitBtn = document.getElementById('submitBtn');

    // helper maps for quick lookup
    const icaoToAircraft = Object.fromEntries(aircraftList.map(a => [a.icao, a]));
    // build livery -> icao lists already present

    // Populate planeSelect with all aircraft (no empty option)
    function populatePlanes(defaultICAO=null){
      planeSelect.innerHTML = '';
      aircraftList.forEach((a, i) => {
        const opt = document.createElement('option');
        opt.value = a.icao;
        opt.textContent = `${a.name} (${a.icao})`;
        planeSelect.appendChild(opt);
      });
      // set selection
      if(defaultICAO && icaoToAircraft[defaultICAO]) planeSelect.value = defaultICAO;
      else planeSelect.selectedIndex = 0;
    }

    // Get a list of livery names that include this ICAO
    function liveriesForICAO(icao){
      return Object.keys(liveries).filter(k => liveries[k].includes(icao));
    }

    // Populate liverySelect based on current plane ICAO; ensure at least one option
    function populateLiveriesForPlane(icao, preferredLivery=null){
      const options = liveriesForICAO(icao);
      liverySelect.innerHTML = '';
      // if there are zero liveries, we still need at least one: show 'Default'
      const finalOptions = options.length ? options : ['Default'];
      finalOptions.forEach((name) => {
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = name;
        liverySelect.appendChild(opt);
      });
      // select preferred if still present, else first
      if(preferredLivery && finalOptions.includes(preferredLivery)){
        liverySelect.value = preferredLivery;
      } else {
        liverySelect.selectedIndex = 0;
      }
    }

    // When livery selected, ensure plane is valid for that livery; if not, pick first plane that matches
    function ensurePlaneForLivery(preferredPlane=null){
      const chosenLivery = liverySelect.value;
      const aircraftForLivery = Object.keys(icaoToAircraft).filter(icao => (liveries[chosenLivery] || []).includes(icao));
      if(!aircraftForLivery.length){
        // nothing matches - keep current plane or pick first
        if(preferredPlane && icaoToAircraft[preferredPlane]) planeSelect.value = preferredPlane;
        else planeSelect.selectedIndex = 0;
        return;
      }
      // if current plane is allowed keep it
      if(aircraftForLivery.includes(planeSelect.value)) return;
      // else pick first allowed plane
      planeSelect.value = aircraftForLivery[0];
      // update liveries list for the newly selected plane (this will keep chosen livery valid)
      populateLiveriesForPlane(planeSelect.value, liverySelect.value);
    }

    // initial population: pick first plane and its liveries
    populatePlanes();
    populateLiveriesForPlane(planeSelect.value);

    // Event: plane changed by user
    planeSelect.addEventListener('change', (e) => {
      const prevLivery = liverySelect.value;
      populateLiveriesForPlane(planeSelect.value, prevLivery);
      // if prevLivery not valid for new plane, populateLiveriesForPlane already selected first
    });

    // Event: livery changed by user
    liverySelect.addEventListener('change', (e) => {
      // Ensure current plane belongs to this livery; if not, pick first plane that supports it.
      ensurePlaneForLivery();
      // Also repopulate livery list for that (maybe redundant but keeps consistency)
      populateLiveriesForPlane(planeSelect.value, liverySelect.value);
    });

    /********************************************************
      Canvas & crop code (keeps the robust cropper)
    *********************************************************/
    const mainCanvas = document.getElementById('mainCanvas');
    const ctx = mainCanvas.getContext('2d', {alpha:false});
    const previewCanvas = document.getElementById('previewCanvas');
    const pctx = previewCanvas.getContext('2d', {alpha:false});

    let image = new Image();
    let imgLoaded = false;
    let drawArea = {x:0,y:0,w:0,h:0};

    function resizeMainCanvas(){
      const box = mainCanvas.parentElement.getBoundingClientRect();
      mainCanvas.width = Math.floor(box.width);
      mainCanvas.height = Math.floor(box.width * 9/16);
    }

    // crop rect (default)
    let crop = {x:20, y:20, w: Math.floor(640*0.7), h: Math.floor((640*0.7)*9/16) };
    const minCropW = 80;
    const handleSize = 20;
    let state = { dragging:false, resizing:false, resizeEdge:null, startX:0, startY:0, startCrop:null };
    let activePointerId = null;

    function clearMain(){ ctx.fillStyle = '#000'; ctx.fillRect(0,0,mainCanvas.width,mainCanvas.height); }

    function fitImageToCanvas(){
      if(!imgLoaded) return;
      const cw = mainCanvas.width, ch = mainCanvas.height;
      const iw = image.width, ih = image.height;
      const canvasRatio = cw / ch;
      const imgRatio = iw / ih;
      let drawW, drawH, offsetX, offsetY;
      if(imgRatio > canvasRatio){
        drawW = cw;
        drawH = Math.round(cw / imgRatio);
        offsetX = 0;
        offsetY = Math.round((ch - drawH)/2);
      } else {
        drawH = ch;
        drawW = Math.round(ch * imgRatio);
        offsetY = 0;
        offsetX = Math.round((cw - drawW)/2);
      }
      drawArea = { x: offsetX, y: offsetY, w: drawW, h: drawH };
      ctx.drawImage(image, offsetX, offsetY, drawW, drawH);
    }

    function drawOverlayAndCrop(){
      if(!imgLoaded) return;
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.fillRect(drawArea.x, drawArea.y, drawArea.w, drawArea.h);

      const sx = Math.max(drawArea.x, crop.x);
      const sy = Math.max(drawArea.y, crop.y);
      const sw = Math.max(0, Math.min(drawArea.x + drawArea.w, crop.x + crop.w) - sx);
      const sh = Math.max(0, Math.min(drawArea.y + drawArea.h, crop.y + crop.h) - sy);
      if(sw > 0 && sh > 0) {
        const scaleX = image.width / drawArea.w;
        const scaleY = image.height / drawArea.h;
        const srcX = (sx - drawArea.x) * scaleX;
        const srcY = (sy - drawArea.y) * scaleY;
        const srcW = sw * scaleX;
        const srcH = sh * scaleY;
        ctx.drawImage(image, srcX, srcY, srcW, srcH, sx, sy, sw, sh);
      }

      // border and handles
      ctx.lineWidth = 3;
      ctx.strokeStyle = 'rgb(255,170,0)';
      ctx.strokeRect(crop.x + 0.5, crop.y + 0.5, crop.w - 1, crop.h - 1);

      const hs = handleSize;
      const handles = [
        {x: crop.x - hs/2, y: crop.y - hs/2, name:'nw'},
        {x: crop.x + crop.w - hs/2, y: crop.y - hs/2, name:'ne'},
        {x: crop.x - hs/2, y: crop.y + crop.h - hs/2, name:'sw'},
        {x: crop.x + crop.w - hs/2, y: crop.y + crop.h - hs/2, name:'se'},
        {x: crop.x + crop.w/2 - hs/2, y: crop.y - hs/2, name:'n'},
        {x: crop.x + crop.w/2 - hs/2, y: crop.y + crop.h - hs/2, name:'s'},
        {x: crop.x - hs/2, y: crop.y + crop.h/2 - hs/2, name:'w'},
        {x: crop.x + crop.w - hs/2, y: crop.y + crop.h/2 - hs/2, name:'e'}
      ];
      ctx.fillStyle = 'rgb(255,170,0)';
      handles.forEach(h => ctx.fillRect(h.x, h.y, hs, hs));
    }

    function renderAll(){
      clearMain();
      if(!imgLoaded) return;
      fitImageToCanvas();
      drawOverlayAndCrop();
      updatePreview();
    }

    function toCanvasCoords(evt){
      const rect = mainCanvas.getBoundingClientRect();
      const x = (evt.clientX - rect.left) * (mainCanvas.width / rect.width);
      const y = (evt.clientY - rect.top) * (mainCanvas.height / rect.height);
      return {x, y};
    }

    function detectHit(x, y){
      const tol = Math.max(12, handleSize/2);
      const corners = {
        nw: {x: crop.x, y: crop.y},
        ne: {x: crop.x + crop.w, y: crop.y},
        sw: {x: crop.x, y: crop.y + crop.h},
        se: {x: crop.x + crop.w, y: crop.y + crop.h}
      };
      for(const k in corners){
        const p = corners[k];
        if(Math.abs(x - p.x) <= tol && Math.abs(y - p.y) <= tol) return {type:'corner', which:k};
      }
      if(y >= crop.y - tol && y <= crop.y + tol && x >= crop.x - tol && x <= crop.x + crop.w + tol) return {type:'edge', which:'n'};
      if(y >= crop.y + crop.h - tol && y <= crop.y + crop.h + tol && x >= crop.x - tol && x <= crop.x + crop.w + tol) return {type:'edge', which:'s'};
      if(x >= crop.x - tol && x <= crop.x + tol && y >= crop.y - tol && y <= crop.y + crop.h + tol) return {type:'edge', which:'w'};
      if(x >= crop.x + crop.w - tol && x <= crop.x + crop.w + tol && y >= crop.y - tol && y <= crop.y + crop.h + tol) return {type:'edge', which:'e'};
      if(x > crop.x + tol && x < crop.x + crop.w - tol && y > crop.y + tol && y < crop.y + crop.h - tol) return {type:'inside'};
      return {type:'none'};
    }

    mainCanvas.addEventListener('pointerdown', (e) => {
      if(!imgLoaded) return;
      mainCanvas.setPointerCapture(e.pointerId);
      activePointerId = e.pointerId;
      const pos = toCanvasCoords(e);
      const hit = detectHit(pos.x, pos.y);
      state.startX = pos.x; state.startY = pos.y; state.startCrop = {...crop};
      if(hit.type === 'corner') { state.resizing = true; state.resizeEdge = hit.which; }
      else if(hit.type === 'edge') { state.resizing = true; state.resizeEdge = hit.which; }
      else if(hit.type === 'inside') { state.dragging = true; }
      else { state.dragging = false; state.resizing = false; state.resizeEdge = null; }
    });

    mainCanvas.addEventListener('pointermove', (e) => {
      if(activePointerId !== null && e.pointerId !== activePointerId) return;
      const pos = toCanvasCoords(e);
      const hit = detectHit(pos.x, pos.y);

      // cursor mapping
      let cursor = 'default';
      if(hit.type === 'corner'){
        if(hit.which === 'nw' || hit.which === 'se') cursor = 'nwse-resize';
        else cursor = 'nesw-resize';
      } else if(hit.type === 'edge'){
        if(hit.which === 'n' || hit.which === 's') cursor = 'ns-resize';
        else if(hit.which === 'e' || hit.which === 'w') cursor = 'ew-resize';
      } else if(hit.type === 'inside'){
        cursor = 'move';
      }
      mainCanvas.style.cursor = cursor;

      if(state.dragging){
        const dx = pos.x - state.startX;
        const dy = pos.y - state.startY;
        crop.x = Math.max(drawArea.x, Math.min(drawArea.x + drawArea.w - crop.w, state.startCrop.x + dx));
        crop.y = Math.max(drawArea.y, Math.min(drawArea.y + drawArea.h - crop.h, state.startCrop.y + dy));
        renderAll();
      } else if(state.resizing){
        const which = state.resizeEdge;
        let newCrop = {...state.startCrop};
        const dx = pos.x - state.startX;
        const dy = pos.y - state.startY;

        // Corners
        if(which === 'se'){
          newCrop.w = Math.max(minCropW, Math.round(state.startCrop.w + dx));
          newCrop.h = Math.round(newCrop.w * 9/16);
        } else if(which === 'sw'){
          newCrop.w = Math.max(minCropW, Math.round(state.startCrop.w - dx));
          newCrop.h = Math.round(newCrop.w * 9/16);
          newCrop.x = state.startCrop.x + (state.startCrop.w - newCrop.w);
        } else if(which === 'ne'){
          newCrop.w = Math.max(minCropW, Math.round(state.startCrop.w + dx));
          newCrop.h = Math.round(newCrop.w * 9/16);
          newCrop.y = state.startCrop.y + (state.startCrop.h - newCrop.h);
        } else if(which === 'nw'){
          newCrop.w = Math.max(minCropW, Math.round(state.startCrop.w - dx));
          newCrop.h = Math.round(newCrop.w * 9/16);
          newCrop.x = state.startCrop.x + (state.startCrop.w - newCrop.w);
          newCrop.y = state.startCrop.y + (state.startCrop.h - newCrop.h);

        // Sides: keep aspect ratio, adjust orthogonal pos to keep centered
        } else if(which === 'e'){
          newCrop.w = Math.max(minCropW, Math.round(state.startCrop.w + dx));
          newCrop.h = Math.round(newCrop.w * 9/16);
          newCrop.y = Math.round(state.startCrop.y + (state.startCrop.h - newCrop.h)/2);
        } else if(which === 'w'){
          newCrop.w = Math.max(minCropW, Math.round(state.startCrop.w - dx));
          newCrop.h = Math.round(newCrop.w * 9/16);
          newCrop.x = state.startCrop.x + (state.startCrop.w - newCrop.w);
          newCrop.y = Math.round(state.startCrop.y + (state.startCrop.h - newCrop.h)/2);
        } else if(which === 'n'){
          newCrop.h = Math.max(Math.round(minCropW * 9/16), Math.round(state.startCrop.h - dy));
          newCrop.w = Math.round(newCrop.h * 16/9);
          newCrop.y = state.startCrop.y + (state.startCrop.h - newCrop.h);
          newCrop.x = Math.round(state.startCrop.x + (state.startCrop.w - newCrop.w)/2);
        } else if(which === 's'){
          newCrop.h = Math.max(Math.round(minCropW * 9/16), Math.round(state.startCrop.h + dy));
          newCrop.w = Math.round(newCrop.h * 16/9);
          newCrop.x = Math.round(state.startCrop.x + (state.startCrop.w - newCrop.w)/2);
        }

        // clamp to drawArea boundaries
        if(newCrop.w > drawArea.w) newCrop.w = drawArea.w;
        if(newCrop.h > drawArea.h) newCrop.h = drawArea.h;
        if(newCrop.x < drawArea.x) newCrop.x = drawArea.x;
        if(newCrop.y < drawArea.y) newCrop.y = drawArea.y;
        if(newCrop.x + newCrop.w > drawArea.x + drawArea.w) newCrop.x = drawArea.x + drawArea.w - newCrop.w;
        if(newCrop.y + newCrop.h > drawArea.y + drawArea.h) newCrop.y = drawArea.y + drawArea.h - newCrop.h;

        crop = newCrop;
        renderAll();
      }
    });

    mainCanvas.addEventListener('pointerup', (e) => {
      if(activePointerId !== null && e.pointerId !== activePointerId) return;
      try{ mainCanvas.releasePointerCapture(e.pointerId); } catch(_) {}
      activePointerId = null;
      state.dragging = false; state.resizing = false; state.resizeEdge = null;
    });

    /********************************************************
      File input handling (native label => single-click)
    *********************************************************/
    fileInput.addEventListener('change', () => {
      const f = fileInput.files[0];
      if(!f) return;
      const url = URL.createObjectURL(f);
      image = new Image();
      image.onload = () => {
        imgLoaded = true;
        resizeMainCanvas();
        crop.w = Math.floor(mainCanvas.width * 0.7);
        crop.h = Math.round(crop.w * 9/16);
        crop.x = Math.round((mainCanvas.width - crop.w)/2);
        crop.y = Math.round((mainCanvas.height - crop.h)/2);
        renderAll();
        URL.revokeObjectURL(url);
      };
      image.src = url;
    });

    /********************************************************
      Live preview: draw the cropped area to previewCanvas
    *********************************************************/
    function updatePreview(){
      if(!imgLoaded){
        pctx.fillStyle = '#000';
        pctx.fillRect(0,0,previewCanvas.width, previewCanvas.height);
        return;
      }
      previewCanvas.width = 1280;
      previewCanvas.height = Math.round(previewCanvas.width * 9/16);

      const sx = Math.max(drawArea.x, crop.x);
      const sy = Math.max(drawArea.y, crop.y);
      const sw = Math.max(0, Math.min(drawArea.x + drawArea.w, crop.x + crop.w) - sx);
      const sh = Math.max(0, Math.min(drawArea.y + drawArea.h, crop.y + crop.h) - sy);

      if(sw <= 0 || sh <= 0){
        pctx.fillStyle = '#000';
        pctx.fillRect(0,0,previewCanvas.width, previewCanvas.height);
        return;
      }

      const scaleX = image.width / drawArea.w;
      const scaleY = image.height / drawArea.h;
      const srcX = (sx - drawArea.x) * scaleX;
      const srcY = (sy - drawArea.y) * scaleY;
      const srcW = sw * scaleX;
      const srcH = sh * scaleY;

      pctx.fillStyle = '#000';
      pctx.fillRect(0,0,previewCanvas.width, previewCanvas.height);
      pctx.drawImage(image, srcX, srcY, srcW, srcH, 0, 0, previewCanvas.width, previewCanvas.height);
    }

    /********************************************************
      Submit (demo): open in new tab (requires image, aircraft, livery, roblox id)
    *********************************************************/
    submitBtn.addEventListener('click', () => {
      const plane = planeSelect.value;
      const livery = liverySelect.value;
      const robloxId = robloxIdInput.value.trim();
      if(!fileInput.files[0] || !plane || !livery || !robloxId){
        // visual feedback
        submitBtn.style.opacity = '0.5';
        setTimeout(()=> submitBtn.style.opacity = '1', 220);
        return;
      }
      const dataURL = previewCanvas.toDataURL('image/jpeg', 0.92);
      const win = window.open();
      if(win){
        win.document.write('<title>Cropped image</title>');
        win.document.write('<div style="font-family: monospace; padding:10px; background:#111; color:#fff;"><strong>Plane:</strong> '+plane+'<br><strong>Livery:</strong> '+livery+'<br><strong>Roblox ID:</strong> '+robloxId+'</div>');
        win.document.write('<img src="'+dataURL+'" style="max-width:100%;display:block;margin:10px auto;">');
      }
    });

    /********************************************************
      Init & responsiveness
    *********************************************************/
    function init(){
      // default selections: first plane and first livery that applies
      populatePlanes();
      const defaultPlane = planeSelect.value;
      populateLiveriesForPlane(defaultPlane);
      resizeMainCanvas();
      crop.w = Math.floor(mainCanvas.width * 0.7);
      crop.h = Math.round(crop.w * 9/16);
      crop.x = Math.round((mainCanvas.width - crop.w)/2);
      crop.y = Math.round((mainCanvas.height - crop.h)/2);
      renderAll();
    }

    window.addEventListener('load', init);
    window.addEventListener('resize', ()=>{
      const prevW = mainCanvas.width;
      resizeMainCanvas();
      const ratio = mainCanvas.width / (prevW || mainCanvas.width);
      crop.w = Math.max(minCropW, Math.round(crop.w * ratio));
      crop.h = Math.round(crop.w * 9/16);
      crop.x = Math.round((mainCanvas.width - crop.w)/2);
      crop.y = Math.round((mainCanvas.height - crop.h)/2);
      renderAll();
    });
  </script>
</body>
</html>
