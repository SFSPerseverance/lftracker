<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LFTracker Aircraft Photos</title>

  <!-- Press Start 2P -->
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

  <style>
    :root {
      --accent: rgb(255, 170, 0);
      --bg: #0b0c10;
      --panel: #111217;
      --white: #FFFFFF;
      --radius: 10px;
      --stroke: 3px;
      --invalid: #ff4d4f;
      --valid: #4caf50;
    }

    /* Global */
    * {
      box-sizing: border-box;
      font-family: 'Press Start 2P', monospace;
      color: var(--white);
    }

    html,
    body {
      height: 100%;
      margin: 0;
      background: var(--bg);
    }

    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: url('../assets/background.png') center/cover no-repeat;
      background-size: cover;
      z-index: 0;
    }

    .wrap {
      max-width: 1000px;
      margin: 28px auto;
      padding: 18px;
    }

    h1 {
      color: var(--accent);
      margin: 0 0 8px;
      font-size: 18px;
      text-align: center;
      -webkit-text-stroke: 2px #000;
      paint-order: stroke fill;
    }

    p.lead {
      color: var(--white);
      text-align: center;
      font-size: 11px;
      margin: 8px 0 18px 0;
      -webkit-text-stroke: 1px #000;
      paint-order: stroke fill;
    }

    .panel {
      background: linear-gradient(90deg, rgba(255, 170, 0, 0.1) 0%, rgba(156, 112, 0, 0.1) 15%, rgba(156, 112, 0, 0.1) 85%, rgba(255, 170, 0, 0.1) 100%), rgba(26, 26, 26, 0.7);
      background-blend-mode: normal;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border-radius: var(--radius);
      border: var(--stroke) solid var(--accent);
      padding: 16px;
    }

    .grid {
      display: grid;
      grid-template-columns: 1fr 520px;
      gap: 18px;
      align-items: start;
    }

    label {
      display: block;
      font-size: 10px;
      margin-bottom: 8px;
      color: var(--white);
      -webkit-text-stroke: 1px #000;
      paint-order: stroke fill;
    }

    /* Controls */
    .controls .control {
      width: 100%;
      margin-bottom: 12px;
    }

    select,
    input[type="text"],
    button,
    .fake-file {
      font-family: 'Press Start 2P', monospace;
      background: transparent;
      color: var(--white);
      border-radius: 8px;
      border: 2px solid var(--accent);
      padding: 10px;
      font-size: 11px;
      width: 100%;
      text-align: left;
      cursor: pointer;
      -webkit-appearance: none;
      appearance: none;
    }

    /* Force dropdown list dark where possible */
    select,
    option {
      background: rgba(11, 12, 16, 0.95) !important;
      color: #FFFFFF !important;
    }

    .inline-row {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .small-note {
      font-size: 10px;
      opacity: 0.9;
      color: var(--white);
    }

    /* Fake file button (we use a label tied to input) */
    .fake-file {
      display: flex;
      align-items: center;
      gap: 12px;
      justify-content: flex-start;
      height: 48px;
      background: transparent;
    }

    .fake-file svg {
      width: 24px;
      height: 24px;
      flex: 0 0 24px;
    }

    .submit-btn {
      background: var(--accent);
      color: #fff !important;
      border: 2px solid rgba(0, 0, 0, 0.25);
      padding: 10px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 11px;
      -webkit-text-stroke: 1px #000;
      paint-order: stroke fill;
      text-align: center;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .meta {
      font-size: 10px;
      color: var(--white);
      opacity: 0.9;
      margin-top: 6px;
    }

    /* Canvas */
    .canvas-wrap {
      background: transparent;
      backdrop-filter: none;
      -webkit-backdrop-filter: none;
      border-radius: 0;
      padding: 0;
      border: none;
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: center;
    }

    .canvas-box {
      width: 100%;
      max-width: 820px;
      background: linear-gradient(90deg, rgba(255, 170, 0, 0.1) 0%, rgba(156, 112, 0, 0.1) 15%, rgba(156, 112, 0, 0.1) 85%, rgba(255, 170, 0, 0.1) 100%), rgba(26, 26, 26, 0.7);
      background-blend-mode: normal;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border-radius: var(--radius);
      border: var(--stroke) solid var(--accent);
      overflow: hidden;
      position: relative;
      aspect-ratio: 16/9;
    }

    #mainCanvas {
      width: 100%;
      height: 100%;
      display: block;
      background: #000;
    }

    #mainCanvas.empty {
      background: rgba(0, 0, 0, 0.6);
      /* semi-transparent instead of just opacity */
      transition: background 160ms ease;
    }

    #robloxId {
      cursor: text;
    }

    .preview-area {
      display: flex;
      gap: 12px;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
      margin-top: 6px;
    }

    #previewCanvas {
      width: 320px;
      height: 180px;
      border-radius: var(--radius);
      border: var(--stroke) solid var(--accent);
      background: linear-gradient(90deg, rgba(255, 170, 0, 0.1) 0%, rgba(156, 112, 0, 0.1) 15%, rgba(156, 112, 0, 0.1) 85%, rgba(255, 170, 0, 0.1) 100%), rgba(26, 26, 26, 0.7);
      background-blend-mode: normal;
    }

    #previewCanvas.empty {
      opacity: 0.6;
      /* semi-transparent */
      transition: opacity 160ms ease;
    }

    /* validation badges */
    .badge {
      display: inline-block;
      font-size: 10px;
      padding: 6px 8px;
      border-radius: 6px;
      color: #000;
      background: var(--valid);
      min-width: 80px;
      text-align: center;
    }

    .badge.invalid {
      background: var(--invalid);
      color: #fff;
    }

    .helper {
      font-size: 11px;
      color: #bbb;
      margin-top: 6px;
      -webkit-text-stroke: 0.5px #000;
      paint-order: stroke fill;
    }

    /* upload progress */
    .progress {
      height: 10px;
      background: rgba(255, 255, 255, 0.06);
      border-radius: 6px;
      overflow: hidden;
      margin-top: 8px;
    }

    .progress>div {
      height: 100%;
      width: 0%;
      background: var(--accent);
      transition: width 0.12s linear;
    }

    /* hide the real input */
    #fileInput,
    #bgInput {
      display: none;
    }

    @media (max-width:980px) {
      .grid {
        grid-template-columns: 1fr;
      }

      .canvas-wrap {
        order: -1;
      }

      #previewCanvas {
        width: 240px;
        height: 135px;
      }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <h1>LFTracker Photo Upload</h1>
    <p class="lead">Upload your photos that you've captured here to be displayed in LFTracker!</p>

    <div class="panel grid">
      <!-- Left: controls -->
      <div class="controls">

        <label for="fileInput">Choose image</label>

        <!-- native label -> single native file picker trigger -->
        <label for="fileInput" class="fake-file control" id="fileLabel" title="Browse image">
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="none" stroke="rgb(255,170,0)"
            stroke-width="2" stroke-linejoin="round" stroke-linecap="round" aria-hidden="true">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
            <polyline points="17 8 12 3 7 8"></polyline>
            <line x1="12" y1="3" x2="12" y2="15"></line>
          </svg>
          <span style="font-size:11px">Browse Image</span>
        </label>

        <input id="fileInput" type="file" accept="image/*">

        <label for="planeSelect">Aircraft</label>
        <select id="planeSelect" class="control" aria-label="Aircraft"></select>

        <label for="liverySelect">Livery</label>
        <select id="liverySelect" class="control" aria-label="Livery"></select>

        <label for="robloxId">Roblox user ID</label>
        <div class="inline-row">
          <input id="robloxId" type="text" placeholder="Enter your Roblox user ID" class="control" style="flex:1" />
          <div id="robloxBadge" style="flex:0 0 auto; margin-left:6px;"></div>
        </div>

        <button id="submitBtn" class="submit-btn control" disabled>Upload</button>

        <div id="uploadStatus" class="helper" style="margin-top:8px"></div>
        <div class="progress" style="display:none" id="progressBar">
          <div></div>
        </div>
      </div>

      <!-- Right: canvas & preview -->
      <div class="canvas-wrap">
        <label>Image</label>
        <div class="canvas-box">
          <canvas id="mainCanvas"></canvas>
        </div>

        <div class="preview-area">
          <div>
            <div style="font-size:10px; margin-bottom:6px; -webkit-text-stroke: 0.5px #000; paint-order: stroke fill;">
              Preview</div>
            <canvas id="previewCanvas" width="1280" height="720"></canvas>
          </div>
        </div>
      </div>
    </div>
    <div
      style="position: fixed; bottom: 16px; left: 16px; font-size: 10px; color: var(--white); -webkit-text-stroke: 0.5px #000; paint-order: stroke fill; opacity: 0.9;">
      Photo by <span id="photographerName">@jaxon1111 from the Discord Server</span>
    </div>
  </div>

  <!-- Supabase client -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.0/dist/umd/supabase.min.js"></script>

  <script>
    const SUPABASE_URL = 'https://qhffydtxzlwoxgllvtif.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFoZmZ5ZHR4emx3b3hnbGx2dGlmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI1NzkwNjAsImV4cCI6MjA3ODE1NTA2MH0.CAacFj8c14KlGu0HJ_1Zjf6hVadaGd5hPJleH8zftIQ';
    const supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    const aircraftList = [
      { icao: 'BA11', name: 'BAC 1-11' },
      { icao: 'B731', name: 'Boeing 737-100' },
      { icao: 'B732', name: 'Boeing 737-200' },
      { icao: 'B733', name: 'Boeing 737-300' },
      { icao: 'B734', name: 'Boeing 737-400' },
      { icao: 'B735', name: 'Boeing 737-500' },
      { icao: 'B73D', name: 'Boeing 737-DEV' },
      { icao: 'L101', name: 'Lockheed L-1011 TriStar' },
      { icao: 'CL60', name: 'Bombardier Challenger 600' },
      { icao: 'TBM7', name: 'Socata TBM-700' },
      { icao: 'A10', name: 'Fairchild Republic A-10' },
      { icao: 'MISC', name: 'Miscellaneous' }
    ];

    const liveries = { "DRAGONAIRTHEOTHERONE": ["L101"], "MALÉV": ["B732"], "RCAF": ["CL60"], "HAPAG-LLOYD": ["B734", "B73D"], "ZBRANIFFLIGHTBLUE": ["BA11"], "BRITISH": ["B734"], "KLM": ["B734"], "AIRFLORIDA X SINGAPORE": ["B732"], "MALAYSIAN": ["B734"], "RYANAIR": ["BA11", "B732"], "SUBSNAIL": ["BA11"], "ZBRANIFFORANGE": ["BA11"], "ROYALCANADA": ["L101"], "BAHAMASAIR": ["BA11"], "PEOPLESEXPRESS": ["B731"], "DELTA": ["L101"], "EASTERN": ["L101"], "INDIAN": ["B732"], "SUN": ["B732"], "BRITISHRAF": ["L101"], "GENERIC": ["BA11", "B731", "B732", "B734", "B735", "A10", "CL60", "B73D", "L101", "TBM7", "Tester"], "PAN AM": ["B732"], "N997JM": ["TBM7"], "ZBRANIFFYELLOWGREENISH": ["BA11"], "N781TM": ["TBM7"], "N700CS": ["TBM7"], "DUBAI": ["BA11"], "TAG": ["CL60"], "N700VJ": ["TBM7"], "ZBRANIFFDARKORANGE": ["BA11"], "PR-TUS": ["TBM7"], "ANSETT": ["B731"], "PIEDMONT2": ["B734"], "ZBRANIFFDARKGREEN": ["BA11"], "FLORIDAEXPRESS": ["BA11"], "ROYALJORDANIAN": ["L101"], "LUFTHANSA YELLOW": ["B732"], "AEROASIA": ["BA11"], "LUFTHANSA CLASSIC": ["B732"], "D-FAYX": ["TBM7"], "CP": ["B732"], "CATHAYPACIFIC": ["L101"], "TWA": ["L101"], "1LEGACYFLIGHT": ["L101"], "LAM": ["L101"], "ZBRANIFFBLUE": ["BA11"], "2-PLAY": ["TBM7"], "BWIA": ["L101"], "AMERICAWEST": ["B731"], "AIRTRANSAT": ["L101"], "THAI": ["B732"], "CONTINENTAL": ["B731", "B735"], "AVIANCA": ["B731"], "ALGERIANAIRFORCE": ["L101"], "ZBRANIFFLIGHTGREEN": ["BA11"], "POKO": ["BA11", "TBM7"], "ANGOLAAIRLINES": ["L101"], "LUFTHANSA OLD": ["B732"], "AIRFRANCE": ["L101"], "BRITISHAIRTOURS": ["L101"], "CONDOR": ["B731"], "HAWAIIAN": ["L101"], "AEROPERú": ["L101"], "LUFTHANSA": ["B731", "B734", "B735"], "TAP": ["L101"], "AIRCALIFORNIA": ["B731"], "LTU": ["L101"], "AIRTRANSATTHEOTHERONE": ["L101"], "ZBRANIFFLIGHTYELLOW": ["BA11"], "ANA": ["B732", "B735"], "ZBRANIFFDARKBLUE": ["BA11"], "PANAM": ["L101"], "SAUDIA": ["L101"], "STARGAZERNG": ["L101"], "BOEING": ["B731"], "CANADAIR": ["CL60"], "N275LH": ["TBM7"], "WORLDWAYS": ["L101"], "PIEDMONT1": ["B734"], "OCEANIC": ["B73D"], "SOUTHWEST": ["B73D"], "STARGAZERORBITAL": ["L101"], "LEGACY": ["BA11"], "GRAY": ["A10"], "USAIR": ["BA11", "B732", "B734", "B73D"], "QANTAS": ["B734"], "ZBRANIFFPALEORANGE": ["BA11"], "CONTINETNAL": ["B732"], "NASA": ["B731"], "CYPRUS": ["BA11"], "SWA": ["B735"], "GREEN": ["A10"], "BRITISHAIRWAYS": ["BA11", "L101"], "SUNINTERNATIONAL": ["B731"], "CHINA SOUTHERN": ["B735"], "HOMELIVERY": ["BA11"], "MAERSKAIR": ["B734"], "AERLINGUS": ["BA11", "L101"], "PSA": ["L101"], "HALLOWEEN ": ["BA11"], "QATAR": ["B73D"], "ZBRANIFFPALE": ["BA11"], "QUEBECAIR": ["BA11"], "AIRCANADA": ["L101"], "TRANS AERO": ["B732"], "2POKO": ["L101"], "SAS": ["BA11", "B735"], "AMERICAN": ["B732"], "UNITED": ["B732", "L101"], "ZBRANIFFEMERALD": ["BA11"], "AER LINGUS": ["B735"], "SWISSAIR": ["BA11"], "DRAGONAIR": ["L101"], "ZBRANIFFRED": ["BA11"], "ALOHA": ["BA11"] };

    const fileInput = document.getElementById('fileInput');
    const planeSelect = document.getElementById('planeSelect');
    const liverySelect = document.getElementById('liverySelect');
    const robloxIdInput = document.getElementById('robloxId');
    const robloxBadge = document.getElementById('robloxBadge');
    const submitBtn = document.getElementById('submitBtn');
    const uploadStatus = document.getElementById('uploadStatus');
    const progressBar = document.getElementById('progressBar');
    const progressInner = progressBar.querySelector('div');

    const icaoToAircraft = Object.fromEntries(aircraftList.map(a => [a.icao, a]));

    // Background image handler

    function populatePlanes(defaultICAO = null) {
      planeSelect.innerHTML = '';
      aircraftList.forEach(a => {
        const opt = document.createElement('option');
        opt.value = a.icao;
        opt.textContent = `${a.name} (${a.icao})`;
        planeSelect.appendChild(opt);
      });
      if (defaultICAO && icaoToAircraft[defaultICAO]) planeSelect.value = defaultICAO;
      else planeSelect.selectedIndex = 0;
    }

    function liveriesForICAO(icao) {
      return Object.keys(liveries).filter(k => liveries[k].includes(icao));
    }

    function populateLiveriesForPlane(icao, preferredLivery = null) {
      const options = liveriesForICAO(icao);
      liverySelect.innerHTML = '';
      const finalOptions = options.length ? options : ['Default'];
      finalOptions.forEach(name => {
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = name;
        liverySelect.appendChild(opt);
      });
      if (preferredLivery && finalOptions.includes(preferredLivery)) liverySelect.value = preferredLivery;
      else liverySelect.selectedIndex = 0;
    }

    function ensurePlaneForLivery(preferredPlane = null) {
      const chosenLivery = liverySelect.value;
      const aircraftForLivery = Object.keys(icaoToAircraft).filter(icao => (liveries[chosenLivery] || []).includes(icao));
      if (!aircraftForLivery.length) {
        if (preferredPlane && icaoToAircraft[preferredPlane]) planeSelect.value = preferredPlane;
        else planeSelect.selectedIndex = 0;
        return;
      }
      if (aircraftForLivery.includes(planeSelect.value)) return;
      planeSelect.value = aircraftForLivery[0];
      populateLiveriesForPlane(planeSelect.value, liverySelect.value);
    }

    populatePlanes();
    populateLiveriesForPlane(planeSelect.value);

    planeSelect.addEventListener('change', () => {
      const prev = liverySelect.value;
      populateLiveriesForPlane(planeSelect.value, prev);
      updateSubmitState();
    });

    liverySelect.addEventListener('change', () => {
      ensurePlaneForLivery();
      populateLiveriesForPlane(planeSelect.value, liverySelect.value);
      updateSubmitState();
    });

    let validateTimer = null;
    let lastValidatedId = null;
    let lastValidResult = null;

    function setBadgeValid(name) {
      robloxBadge.innerHTML = '';
      const span = document.createElement('div');
      span.className = 'badge';
      span.textContent = name;
      robloxBadge.appendChild(span);
    }
    function setBadgeInvalid(msg) {
      robloxBadge.innerHTML = '';
      const span = document.createElement('div');
      span.className = 'badge invalid';
      span.textContent = msg;
      robloxBadge.appendChild(span);
    }
    function clearBadge() { robloxBadge.innerHTML = ''; }

    function isNumericId(s) { return /^\d+$/.test(s); }

    function updateSubmitState() {
      const hasImage = !!fileInput.files[0];
      const plane = planeSelect.value;
      const livery = liverySelect.value;
      const robloxOk = !!lastValidResult;
      submitBtn.disabled = !(hasImage && plane && livery && robloxOk);
    }

    async function validateRobloxId(id) {
      if (!id || !isNumericId(id)) {
        lastValidatedId = id;
        lastValidResult = null;
        setBadgeInvalid('Invalid ID');
        updateSubmitState();
        return;
      }
      if (lastValidatedId === id && lastValidResult) {
        setBadgeValid(lastValidResult.displayName || lastValidResult.name || ('@' + lastValidResult.id));
        updateSubmitState();
        return;
      }

      robloxBadge.innerHTML = '';
      const checking = document.createElement('div');
      checking.className = 'badge';
      checking.style.background = 'transparent';
      checking.style.color = 'var(--white)';
      checking.style.border = '2px solid rgba(255,255,255,0.08)';
      checking.textContent = 'Checking...';
      robloxBadge.appendChild(checking);

      const endpoint = `https://users.roproxy.com/v1/users/${encodeURIComponent(id)}`;
      try {
        const r = await fetch(endpoint, { method: 'GET' });
        if (r.ok) {
          const data = await r.json();
          lastValidatedId = id;
          lastValidResult = data;
          const display = data.displayName || data.name || ('@' + data.id);
          setBadgeValid(display);
        } else if (r.status === 404) {
          lastValidatedId = id;
          lastValidResult = null;
          setBadgeInvalid('Not found');
        } else {
          lastValidatedId = id;
          lastValidResult = null;
          setBadgeInvalid('Validation failed');
        }
      } catch (err) {
        lastValidatedId = id;
        lastValidResult = null;
        setBadgeInvalid('Network error');
      }
      updateSubmitState();
    }

    robloxIdInput.addEventListener('input', (e) => {
      const cleaned = (e.target.value || '').replace(/[^\d]/g, '');
      if (cleaned !== e.target.value) e.target.value = cleaned;
      if (validateTimer) clearTimeout(validateTimer);
      validateTimer = setTimeout(() => validateRobloxId(cleaned), 600);
      lastValidResult = null;
      clearBadge();
      updateSubmitState();
    });

    robloxIdInput.addEventListener('blur', (e) => {
      const id = (e.target.value || '').trim();
      if (validateTimer) { clearTimeout(validateTimer); validateTimer = null; }
      validateRobloxId(id);
    });

    const mainCanvas = document.getElementById('mainCanvas');
    const ctx = mainCanvas.getContext('2d', { alpha: true });
    const previewCanvas = document.getElementById('previewCanvas');
    const pctx = previewCanvas.getContext('2d', { alpha: true });

    let image = new Image();
    let imgLoaded = false;
    let drawArea = { x: 0, y: 0, w: 0, h: 0 };

    function resizeMainCanvas() {
      const box = mainCanvas.parentElement.getBoundingClientRect();
      mainCanvas.width = Math.floor(box.width);
      mainCanvas.height = Math.floor(box.width * 9 / 16);
    }

    let crop = { x: 20, y: 20, w: Math.floor(640 * 0.7), h: Math.floor((640 * 0.7) * 9 / 16) };
    const minCropW = 80;
    const handleSize = 20;
    let state = { dragging: false, resizing: false, resizeEdge: null, startX: 0, startY: 0, startCrop: null };
    let activePointerId = null;

    function clearMain() {
      if (!imgLoaded) {
        mainCanvas.classList.add('empty'); // add semi-transparent background
        ctx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
        return;
      }
      mainCanvas.classList.remove('empty'); // remove when image is loaded
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, mainCanvas.width, mainCanvas.height);
    }

    function fitImageToCanvas() {
      if (!imgLoaded) return;
      const cw = mainCanvas.width, ch = mainCanvas.height;
      const iw = image.width, ih = image.height;
      const canvasRatio = cw / ch;
      const imgRatio = iw / ih;
      let drawW, drawH, offsetX, offsetY;
      if (imgRatio > canvasRatio) {
        drawW = cw;
        drawH = Math.round(cw / imgRatio);
        offsetX = 0;
        offsetY = Math.round((ch - drawH) / 2);
      } else {
        drawH = ch;
        drawW = Math.round(ch * imgRatio);
        offsetY = 0;
        offsetX = Math.round((cw - drawW) / 2);
      }
      drawArea = { x: offsetX, y: offsetY, w: drawW, h: drawH };
      ctx.drawImage(image, offsetX, offsetY, drawW, drawH);
    }

    function drawOverlayAndCrop() {
      if (!imgLoaded) return;
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.fillRect(drawArea.x, drawArea.y, drawArea.w, drawArea.h);

      const sx = Math.max(drawArea.x, crop.x);
      const sy = Math.max(drawArea.y, crop.y);
      const sw = Math.max(0, Math.min(drawArea.x + drawArea.w, crop.x + crop.w) - sx);
      const sh = Math.max(0, Math.min(drawArea.y + drawArea.h, crop.y + crop.h) - sy);
      if (sw > 0 && sh > 0) {
        const scaleX = image.width / drawArea.w;
        const scaleY = image.height / drawArea.h;
        const srcX = (sx - drawArea.x) * scaleX;
        const srcY = (sy - drawArea.y) * scaleY;
        const srcW = sw * scaleX;
        const srcH = sh * scaleY;
        ctx.drawImage(image, srcX, srcY, srcW, srcH, sx, sy, sw, sh);
      }

      ctx.lineWidth = 3;
      ctx.strokeStyle = 'rgb(255,170,0)';
      ctx.strokeRect(crop.x + 0.5, crop.y + 0.5, crop.w - 1, crop.h - 1);

      const hs = handleSize;
      const handles = [
        { x: crop.x - hs / 2, y: crop.y - hs / 2, name: 'nw' },
        { x: crop.x + crop.w - hs / 2, y: crop.y - hs / 2, name: 'ne' },
        { x: crop.x - hs / 2, y: crop.y + crop.h - hs / 2, name: 'sw' },
        { x: crop.x + crop.w - hs / 2, y: crop.y + crop.h - hs / 2, name: 'se' },
        { x: crop.x + crop.w / 2 - hs / 2, y: crop.y - hs / 2, name: 'n' },
        { x: crop.x + crop.w / 2 - hs / 2, y: crop.y + crop.h - hs / 2, name: 's' },
        { x: crop.x - hs / 2, y: crop.y + crop.h / 2 - hs / 2, name: 'w' },
        { x: crop.x + crop.w - hs / 2, y: crop.y + crop.h / 2 - hs / 2, name: 'e' }
      ];
      ctx.fillStyle = 'rgb(255,170,0)';
      handles.forEach(h => ctx.fillRect(h.x, h.y, hs, hs));
    }

    function renderAll() {
      clearMain();
      if (!imgLoaded) return;
      fitImageToCanvas();
      drawOverlayAndCrop();
      updatePreview();
    }

    function toCanvasCoords(evt) {
      const rect = mainCanvas.getBoundingClientRect();
      const x = (evt.clientX - rect.left) * (mainCanvas.width / rect.width);
      const y = (evt.clientY - rect.top) * (mainCanvas.height / rect.height);
      return { x, y };
    }

    function detectHit(x, y) {
      const tol = Math.max(12, handleSize / 2);
      const corners = {
        nw: { x: crop.x, y: crop.y },
        ne: { x: crop.x + crop.w, y: crop.y },
        sw: { x: crop.x, y: crop.y + crop.h },
        se: { x: crop.x + crop.w, y: crop.y + crop.h }
      };
      for (const k in corners) {
        const p = corners[k];
        if (Math.abs(x - p.x) <= tol && Math.abs(y - p.y) <= tol) return { type: 'corner', which: k };
      }
      if (y >= crop.y - tol && y <= crop.y + tol && x >= crop.x - tol && x <= crop.x + crop.w + tol) return { type: 'edge', which: 'n' };
      if (y >= crop.y + crop.h - tol && y <= crop.y + crop.h + tol && x >= crop.x - tol && x <= crop.x + crop.w + tol) return { type: 'edge', which: 's' };
      if (x >= crop.x - tol && x <= crop.x + tol && y >= crop.y - tol && y <= crop.y + crop.h + tol) return { type: 'edge', which: 'w' };
      if (x >= crop.x + crop.w - tol && x <= crop.x + crop.w + tol && y >= crop.y - tol && y <= crop.y + crop.h + tol) return { type: 'edge', which: 'e' };
      if (x > crop.x + tol && x < crop.x + crop.w - tol && y > crop.y + tol && y < crop.y + crop.h - tol) return { type: 'inside' };
      return { type: 'none' };
    }

    mainCanvas.addEventListener('pointerdown', (e) => {
      if (!imgLoaded) return;
      mainCanvas.setPointerCapture(e.pointerId);
      activePointerId = e.pointerId;
      const pos = toCanvasCoords(e);
      const hit = detectHit(pos.x, pos.y);
      state.startX = pos.x; state.startY = pos.y; state.startCrop = { ...crop };
      if (hit.type === 'corner') { state.resizing = true; state.resizeEdge = hit.which; }
      else if (hit.type === 'edge') { state.resizing = true; state.resizeEdge = hit.which; }
      else if (hit.type === 'inside') { state.dragging = true; }
      else { state.dragging = false; state.resizing = false; state.resizeEdge = null; }
    });

    mainCanvas.addEventListener('pointermove', (e) => {
      if (activePointerId !== null && e.pointerId !== activePointerId) return;
      const pos = toCanvasCoords(e);
      const hit = detectHit(pos.x, pos.y);

      let cursor = 'default';
      if (hit.type === 'corner') {
        if (hit.which === 'nw' || hit.which === 'se') cursor = 'nwse-resize';
        else cursor = 'nesw-resize';
      } else if (hit.type === 'edge') {
        if (hit.which === 'n' || hit.which === 's') cursor = 'ns-resize';
        else if (hit.which === 'e' || hit.which === 'w') cursor = 'ew-resize';
      } else if (hit.type === 'inside') {
        cursor = 'move';
      }
      mainCanvas.style.cursor = cursor;

      if (state.dragging) {
        const dx = pos.x - state.startX;
        const dy = pos.y - state.startY;
        crop.x = Math.max(drawArea.x, Math.min(drawArea.x + drawArea.w - crop.w, state.startCrop.x + dx));
        crop.y = Math.max(drawArea.y, Math.min(drawArea.y + drawArea.h - crop.h, state.startCrop.y + dy));
        renderAll();
      } else if (state.resizing) {
        const which = state.resizeEdge;
        let newCrop = { ...state.startCrop };
        const dx = pos.x - state.startX;
        const dy = pos.y - state.startY;

        if (which === 'se') {
          newCrop.w = Math.max(minCropW, Math.round(state.startCrop.w + dx));
          newCrop.h = Math.round(newCrop.w * 9 / 16);
        } else if (which === 'sw') {
          newCrop.w = Math.max(minCropW, Math.round(state.startCrop.w - dx));
          newCrop.h = Math.round(newCrop.w * 9 / 16);
          newCrop.x = state.startCrop.x + (state.startCrop.w - newCrop.w);
        } else if (which === 'ne') {
          newCrop.w = Math.max(minCropW, Math.round(state.startCrop.w + dx));
          newCrop.h = Math.round(newCrop.w * 9 / 16);
          newCrop.y = state.startCrop.y + (state.startCrop.h - newCrop.h);
        } else if (which === 'nw') {
          newCrop.w = Math.max(minCropW, Math.round(state.startCrop.w - dx));
          newCrop.h = Math.round(newCrop.w * 9 / 16);
          newCrop.x = state.startCrop.x + (state.startCrop.w - newCrop.w);
          newCrop.y = state.startCrop.y + (state.startCrop.h - newCrop.h);

        } else if (which === 'e') {
          newCrop.w = Math.max(minCropW, Math.round(state.startCrop.w + dx));
          newCrop.h = Math.round(newCrop.w * 9 / 16);
          newCrop.y = Math.round(state.startCrop.y + (state.startCrop.h - newCrop.h) / 2);
        } else if (which === 'w') {
          newCrop.w = Math.max(minCropW, Math.round(state.startCrop.w - dx));
          newCrop.h = Math.round(newCrop.w * 9 / 16);
          newCrop.x = state.startCrop.x + (state.startCrop.w - newCrop.w);
          newCrop.y = Math.round(state.startCrop.y + (state.startCrop.h - newCrop.h) / 2);
        } else if (which === 'n') {
          newCrop.h = Math.max(Math.round(minCropW * 9 / 16), Math.round(state.startCrop.h - dy));
          newCrop.w = Math.round(newCrop.h * 16 / 9);
          newCrop.y = state.startCrop.y + (state.startCrop.h - newCrop.h);
          newCrop.x = Math.round(state.startCrop.x + (state.startCrop.w - newCrop.w) / 2);
        } else if (which === 's') {
          newCrop.h = Math.max(Math.round(minCropW * 9 / 16), Math.round(state.startCrop.h + dy));
          newCrop.w = Math.round(newCrop.h * 16 / 9);
          newCrop.x = Math.round(state.startCrop.x + (state.startCrop.w - newCrop.w) / 2);
        }

        if (newCrop.w > drawArea.w) newCrop.w = drawArea.w;
        if (newCrop.h > drawArea.h) newCrop.h = drawArea.h;
        if (newCrop.x < drawArea.x) newCrop.x = drawArea.x;
        if (newCrop.y < drawArea.y) newCrop.y = drawArea.y;
        if (newCrop.x + newCrop.w > drawArea.x + drawArea.w) newCrop.x = drawArea.x + drawArea.w - newCrop.w;
        if (newCrop.y + newCrop.h > drawArea.y + drawArea.h) newCrop.y = drawArea.y + drawArea.h - newCrop.h;

        crop = newCrop;
        renderAll();
      }
    });

    mainCanvas.addEventListener('pointerup', (e) => {
      if (activePointerId !== null && e.pointerId !== activePointerId) return;
      try { mainCanvas.releasePointerCapture(e.pointerId); } catch (_) { }
      activePointerId = null;
      state.dragging = false; state.resizing = false; state.resizeEdge = null;
    });

    fileInput.addEventListener('change', () => {
      const f = fileInput.files[0];
      if (!f) return;
      const url = URL.createObjectURL(f);
      image = new Image();
      image.onload = () => {
        imgLoaded = true;
        resizeMainCanvas();
        crop.w = Math.floor(mainCanvas.width * 0.7);
        crop.h = Math.round(crop.w * 9 / 16);
        crop.x = Math.round((mainCanvas.width - crop.w) / 2);
        crop.y = Math.round((mainCanvas.height - crop.h) / 2);
        renderAll();
        URL.revokeObjectURL(url);
        updateSubmitState();
      };
      image.src = url;
    });

    function updatePreview() {
      if (!imgLoaded) {
        // Make the canvas transparent so the CSS background shows
        previewCanvas.width = 1280;
        previewCanvas.height = Math.round(previewCanvas.width * 9 / 16);
        pctx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);

        // Add the "empty" class to dim the preview
        previewCanvas.classList.add('empty');
        return;
      }

      // Remove dim when we have an image
      previewCanvas.classList.remove('empty');

      previewCanvas.width = 1280;
      previewCanvas.height = Math.round(previewCanvas.width * 9 / 16);

      // existing draw logic...
      const sx = Math.max(drawArea.x, crop.x);
      const sy = Math.max(drawArea.y, crop.y);
      const sw = Math.max(0, Math.min(drawArea.x + drawArea.w, crop.x + crop.w) - sx);
      const sh = Math.max(0, Math.min(drawArea.y + drawArea.h, crop.y + crop.h) - sy);

      if (sw <= 0 || sh <= 0) {
        pctx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
        return;
      }

      const scaleX = image.width / drawArea.w;
      const scaleY = image.height / drawArea.h;
      const srcX = (sx - drawArea.x) * scaleX;
      const srcY = (sy - drawArea.y) * scaleY;
      const srcW = sw * scaleX;
      const srcH = sh * scaleY;

      pctx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
      pctx.drawImage(image, srcX, srcY, srcW, srcH, 0, 0, previewCanvas.width, previewCanvas.height);
    }

    function buildPath(filename) {
      const ts = new Date().toISOString().replace(/[:.]/g, '-');
      const ext = (filename.split('.').pop() || 'jpg').toLowerCase();
      const rand = Math.random().toString(36).slice(2, 9);
      return `photos/${ts}_${rand}.${ext}`;
    }

    function computeCropJson() {
      if (!imgLoaded) return null;
      const sx = Math.max(drawArea.x, crop.x);
      const sy = Math.max(drawArea.y, crop.y);
      const sw = Math.max(0, Math.min(drawArea.x + drawArea.w, crop.x + crop.w) - sx);
      const sh = Math.max(0, Math.min(drawArea.y + drawArea.h, crop.y + crop.h) - sy);
      const scaleX = image.width / drawArea.w;
      const scaleY = image.height / drawArea.h;
      const srcX = Math.round((sx - drawArea.x) * scaleX);
      const srcY = Math.round((sy - drawArea.y) * scaleY);
      const srcW = Math.round(sw * scaleX);
      const srcH = Math.round(sh * scaleY);
      return {
        srcX, srcY, srcW, srcH,
        imageWidth: image.width,
        imageHeight: image.height,
        normalized: {
          x: +(srcX / image.width).toFixed(6),
          y: +(srcY / image.height).toFixed(6),
          w: +(srcW / image.width).toFixed(6),
          h: +(srcH / image.height).toFixed(6)
        }
      };
    }

    async function uploadPhotoAndMetadata(file, meta) {
      console.log('Starting upload, supabase client:', supabaseClient);

      const path = buildPath(file.name);

      progressBar.style.display = 'block';
      progressInner.style.width = '10%';
      //uploadStatus.textContent = 'Uploading file...';

      const { data: uploadData, error: uploadErr } = await supabaseClient.storage
        .from('images')
        .upload(path, file, {
          cacheControl: '3600',
          upsert: false
        });

      if (uploadErr) {
        console.error('Upload error:', uploadErr);
        progressBar.style.display = 'none';

        if (uploadErr.message && uploadErr.message.includes('Bucket not found')) {
          throw new Error('Storage bucket "photos" not found. Please create it in Supabase Dashboard → Storage → New Bucket (name: photos, make it public)');
        } else if (uploadErr.message && uploadErr.message.includes('permission')) {
          throw new Error('Permission denied. Check your bucket policies in Supabase Dashboard');
        }

        throw new Error(uploadErr.message || 'Upload failed');
      }

      progressInner.style.width = '50%';
      //uploadStatus.textContent = 'Getting public URL...';

      const { data: publicData } = supabaseClient.storage
        .from('images')
        .getPublicUrl(path);

      const publicUrl = publicData?.publicUrl || null;

      if (!publicUrl) {
        throw new Error('Failed to get public URL');
      }

      progressInner.style.width = '75%';
      //uploadStatus.textContent = 'Saving metadata...';

      const insertRow = {
        file_path: path,
        public_url: publicUrl,
        icao: meta.icao,
        livery: meta.livery,
        uploader_id: meta.robloxId,
        crop_json: meta.crop || null
      };

      const { data: rowData, error: rowErr } = await supabaseClient
        .from('images')
        .insert([insertRow])
        .select()
        .single();

      if (rowErr) {
        console.error('Metadata insert error:', rowErr);

        if (rowErr.message && rowErr.message.includes('relation') && rowErr.message.includes('does not exist')) {
          progressBar.style.display = 'none';
          throw new Error('Table "photos" does not exist. Please create it in Supabase Dashboard');
        } else if (rowErr.message && rowErr.message.includes('permission')) {
          progressBar.style.display = 'none';
          throw new Error('Permission denied for table insert. Check RLS policies');
        }

        try {
          await supabaseClient.storage.from('photos').remove([path]);
        } catch (cleanupErr) {
          console.error('Cleanup error:', cleanupErr);
        }
        progressBar.style.display = 'none';
        throw new Error(rowErr.message || 'Failed to save metadata');
      }

      progressInner.style.width = '100%';
      // uploadStatus.textContent = 'Upload complete!';

      setTimeout(() => {
        progressBar.style.display = 'none';
        progressInner.style.width = '0%';
      }, 1200);

      return { row: rowData, publicUrl };
    }

    submitBtn.addEventListener('click', async () => {
      const file = fileInput.files[0];
      const plane = planeSelect.value;
      const livery = liverySelect.value;
      const robloxId = robloxIdInput.value.trim();

      if (!file || !plane || !livery || !lastValidResult) {
        // uploadStatus.textContent = 'Fill all fields and validate Roblox ID.';
        return;
      }

      submitBtn.disabled = true;
      submitBtn.textContent = 'Uploading...';
      // uploadStatus.textContent = '';

      const cropJson = computeCropJson();
      const meta = {
        icao: plane,
        livery: livery,
        robloxId: robloxId,
        crop: cropJson
      };

      try {
        const res = await uploadPhotoAndMetadata(file, meta);
        // uploadStatus.innerHTML = `✓ Upload successful! <a href="${res.publicUrl}" target="_blank" style="color:var(--accent); text-decoration:underline">View image</a>`;
        submitBtn.textContent = 'Upload';
      } catch (err) {
        console.error('Upload failed:', err);
        //  uploadStatus.textContent = '✗ Upload failed: ' + (err.message || 'Unknown error');
        submitBtn.textContent = 'Upload';
      } finally {
        submitBtn.disabled = false;
        updateSubmitState();
      }
    });

    function init() {
      console.log('Supabase client:', supabaseClient);

      populatePlanes();
      populateLiveriesForPlane(planeSelect.value);
      resizeMainCanvas();
      crop.w = Math.floor(mainCanvas.width * 0.7);
      crop.h = Math.round(crop.w * 9 / 16);
      crop.x = Math.round((mainCanvas.width - crop.w) / 2);
      crop.y = Math.round((mainCanvas.height - crop.h) / 2);
      renderAll();
      updateSubmitState();
    }

    window.addEventListener('load', init);
    window.addEventListener('resize', () => {
      const prevW = mainCanvas.width;
      resizeMainCanvas();
      const ratio = mainCanvas.width / (prevW || mainCanvas.width);
      crop.w = Math.max(minCropW, Math.round(crop.w * ratio));
      crop.h = Math.round(crop.w * 9 / 16);
      crop.x = Math.round((mainCanvas.width - crop.w) / 2);
      crop.y = Math.round((mainCanvas.height - crop.h) / 2);
      renderAll();
      updateSubmitState();
    });
  </script>
</body>

</html>